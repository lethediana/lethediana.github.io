<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>项目搭建</title>
    <url>/2023/05/24/Arduino01/</url>
    <content><![CDATA[<div class="note-large notel-blue"><div class="notel-title"><p>1、说在前面</p>
</div><div class="notel-content"><div class="note note-success icon-padding"><i class="note-icon fa-solid fa-check-circle"></i><p>1、需求描述</p>
</div>
通过识别指纹开发板控制舵机模拟开门的目的。
我想的是温湿度烟雾和指纹模块都可以实现让舵机转动。
同时温湿度和烟雾传感器还能控制蜂鸣器。
传感器：温湿度传感器、烟雾传感器、指纹模块、光感传感器、舵机、蜂鸣器。
<div class="note note-success icon-padding"><i class="note-icon fa-solid fa-check-circle"></i><p>2、实现流程</p>
</div>
功能一:指纹模块+舵机
功能二:温湿度传感器+舵机+蜂鸣器
功能三:烟雾传感器+舵机+蜂鸣器
功能四:光感传感器
准备材料。开始实验。 </div></div>


<div class="note-large notel-blue"><div class="notel-title"><p>2、准备材料</p>
</div><div class="notel-content"><p>使用的材料是：<br>          指纹识别模块（带USB转TTL板）<br>          舵机（度数可调）<br>          温湿度传感器<br>          光感传感器<br>          烟雾传感器<br>          蜂鸣器<br>          风扇模块<br>          LED灯<br>          若干根合适长度的杜邦线</p>
 </div></div>


<div class="note-large notel-blue"><div class="notel-title"><p>3、指纹调试</p>
</div><div class="notel-content"><p>使用USB转TTL板连接指纹模块和电脑。  </p>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>1、Vi模块电源正输入端（红）——TTL板3.3V(注意)</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>2、Tx串行数据输出（黄）——TTL板Rx</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>3、Rx串行数据输入（白）——TTL板Tx</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>4、GND信号地（黑）——TTL板GND</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>5、打开“设备管理器”查看并记录TTL板的端口号。</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>6、运行指纹程序，打开该端口的指纹模块。</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>7、录入指纹速度慢可以取消勾选“显示图像”。<br>（建议录入指纹时，波特率选择57600）。</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>8、录入指纹完成后拔掉TTL板，使用杜邦线连接开发板指纹模块和舵机。</p>
</div> </div></div>

<div class="note-large notel-blue"><div class="notel-title"><p>4、线路连接</p>
</div><div class="notel-content"><p>准备合适长度的杜邦线若干。</p>
<div class="note note-primary icon-padding"><i class="note-icon fa-solid fa-circle-arrow-right"></i><p>1、舵机连接步骤：</p>
</div>
舵机（红色） 线为电源线 —— 开发板5V接口（供电）
舵机（棕黑色）线为地线 —— 开发板GND接口（地线）
舵机（橙黄色）线为信号线 —— 开发板9号口（信号）
<div class="note note-primary icon-padding"><i class="note-icon fa-solid fa-circle-arrow-right"></i><p>2、指纹模块连接步骤：</p>
</div>
指纹模块（红色绿色）线延长接成1根线 —— 开发板3.3V口（供电）
指纹模块（黑色）线 —— 开发板GND接口（地线）
指纹模块（黄色）线 —— 开发板数字2号口（串行数据输出）
指纹模块（白色）线 —— 开发板数字3号口（串行数据输入）
指纹模块（蓝色）线 —— 开发板数字4号口（感应信号输出）
<div class="note note-primary icon-padding"><i class="note-icon fa-solid fa-circle-arrow-right"></i><p>3、温湿度模块连接步骤：</p>
</div>
温湿度模块S引脚 —— 开发板模拟口
温湿度模块VCC引脚 —— 开发板VCC引脚
温湿度模块GND引脚 —— 开发板GND引脚
<div class="note note-primary icon-padding"><i class="note-icon fa-solid fa-circle-arrow-right"></i><p>4、光感模块连接步骤：</p>
</div>
光感模块S引脚 —— 开发板模拟口
光感模块VCC引脚 —— 开发板VCC引脚
光感模块GND引脚 —— 开发板GND引脚
<div class="note note-primary icon-padding"><i class="note-icon fa-solid fa-circle-arrow-right"></i><p>5、烟雾模块连接步骤：</p>
</div>
烟雾模块S引脚 —— 开发板模拟口
烟雾模块VCC引脚 —— 开发板VCC引脚
烟雾模块GND引脚 —— 开发板GND引脚
<div class="note note-primary icon-padding"><i class="note-icon fa-solid fa-circle-arrow-right"></i><p>6、蜂鸣器模块连接步骤：</p>
</div>
蜂鸣器模块数字引脚 —— 开发板数字引脚
蜂鸣器模块GND引脚 —— 开发板GND引脚 </div></div>

<div class="note-large notel-blue"><div class="notel-title"><p>5、代码实现</p>
</div><div class="notel-content"><div class="note note-red icon-padding"><i class="note-icon fa-solid fa-bolt"></i><p>1、把开发板连接电脑，选择开发板的端口（工具→端口→选择端口），复制以下代码进Arduino程序。</p>
</div>
<div class="note note-red icon-padding"><i class="note-icon fa-solid fa-bolt"></i><p>2、如果缺少库文件，就在“工具→管理库”里面搜索添加提示缺失的库即可。</p>
</div>
<div class="note note-red icon-padding"><i class="note-icon fa-solid fa-bolt"></i><p>3、左上角√图标编译验证没问题，就可以上传→至开发板内了。</p>
</div>
<div class="note note-red icon-padding"><i class="note-icon fa-solid fa-bolt"></i><p>4、源代码实现 (代码还须根据实际进行修改和调整)</p>
</div> </div></div>


<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;DFRobot_DHT11.h&gt;</span><br><span class="line">DFRobot_DHT11 DHT;</span><br><span class="line">#define DHT11_PIN A2                  // 对应的是A0引脚</span><br><span class="line">#include &lt;Adafruit_Fingerprint.h&gt;  //声明调用Adafruit_Fingerprint.h库  指纹</span><br><span class="line">#include &lt;Servo.h&gt;    // 声明调用Servo.h库  舵机</span><br><span class="line">Servo myservo;        // 创建一个舵机对象</span><br><span class="line">int pos = 0;          // 变量pos用来存储舵机位置</span><br><span class="line">const int servoDelay = 15;</span><br><span class="line">const int servoStop  = 2000;</span><br><span class="line">const int lowPowerRate = 1;</span><br><span class="line">const int checkDelay = 1000;</span><br><span class="line">const int debug = 0;</span><br><span class="line">int beep = 6;//定义数字口6控制蜂鸣器</span><br><span class="line">/*光感*/</span><br><span class="line">#define lightR A0</span><br><span class="line">#define LED 13</span><br><span class="line">/*光感*/</span><br><span class="line"></span><br><span class="line">#if (defined(__AVR__) || defined(ESP8266)) &amp;&amp; !defined(__AVR_ATmega2560__)</span><br><span class="line">// For UNO and others without hardware serial, we must use software serial...</span><br><span class="line">// pin #2 is IN from sensor (GREEN wire)</span><br><span class="line">// pin #3 is OUT from arduino  (WHITE wire)</span><br><span class="line">// Set up the serial port to use softwareserial..</span><br><span class="line">SoftwareSerial mySerial(2, 3);//黄色串行数据输出&amp;&amp;白色串行数据输入接口（可修改范围A0~A5，2~13）</span><br><span class="line"> </span><br><span class="line">#else</span><br><span class="line">// On Leonardo/M0/etc, others with hardware serial, use hardware serial!</span><br><span class="line">// #0 is green wire, #1 is white</span><br><span class="line">#define mySerial Serial1</span><br><span class="line"> </span><br><span class="line">#endif</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Adafruit_Fingerprint finger = Adafruit_Fingerprint(&amp;mySerial);</span><br><span class="line"> </span><br><span class="line">void setup()</span><br><span class="line">&#123;</span><br><span class="line">  pinMode(LED,OUTPUT);    //设置连接小灯的引脚为输出模式</span><br><span class="line">  pinMode(lightR,INPUT);</span><br><span class="line">  pinMode(beep,OUTPUT);//设置数字6引脚为输出模式 </span><br><span class="line">  myservo.attach(9); //舵机信号端口（可修改范围A0~A5，2~13）</span><br><span class="line">  myservo.write(0);</span><br><span class="line">  Serial.begin(9600);</span><br><span class="line">  Serial.println(&quot;Demo Start&quot;);</span><br><span class="line">  while (!Serial);  // For Yun/Leo/Micro/Zero/...</span><br><span class="line">  delay(100);</span><br><span class="line">  Serial.println(&quot;\n\nAdafruit finger detect test&quot;);</span><br><span class="line"> </span><br><span class="line">  // set the data rate for the sensor serial port</span><br><span class="line">  finger.begin(57600);//设置传感器串行端口的数据速率</span><br><span class="line">  delay(5);</span><br><span class="line">  if (finger.verifyPassword()) &#123;</span><br><span class="line">    Serial.println(&quot;Found fingerprint sensor!&quot;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    Serial.println(&quot;Did not find fingerprint sensor :(&quot;));</span><br><span class="line">    while (1) &#123; delay(1); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  Serial.println(F(&quot;Reading sensor parameters&quot;));</span><br><span class="line">  finger.getParameters();</span><br><span class="line">  Serial.print(F(&quot;Status: 0x&quot;)); Serial.println(finger.status_reg, HEX);</span><br><span class="line">  Serial.print(F(&quot;Sys ID: 0x&quot;)); Serial.println(finger.system_id, HEX);</span><br><span class="line">  Serial.print(F(&quot;Capacity: &quot;)); Serial.println(finger.capacity);</span><br><span class="line">  Serial.print(F(&quot;Security level: &quot;)); Serial.println(finger.security_level);</span><br><span class="line">  Serial.print(F(&quot;Device address: &quot;)); Serial.println(finger.device_addr, HEX);</span><br><span class="line">  Serial.print(F(&quot;Packet len: &quot;)); Serial.println(finger.packet_len);</span><br><span class="line">  Serial.print(F(&quot;Baud rate: &quot;)); Serial.println(finger.baud_rate);</span><br><span class="line"> </span><br><span class="line">  finger.getTemplateCount();</span><br><span class="line"> </span><br><span class="line">  if (finger.templateCount == 0) &#123;</span><br><span class="line">    Serial.print(&quot;Sensor doesn&#x27;t contain any fingerprint data. Please run the &#x27;enroll&#x27; example.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    Serial.println(&quot;Waiting for valid finger...&quot;);</span><br><span class="line">    Serial.print(&quot;Sensor contains &quot;); Serial.print(finger.templateCount); Serial.println(&quot; templates&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void loop()                     // run over and over again</span><br><span class="line">&#123;</span><br><span class="line">  huoyanbaojing();</span><br><span class="line">  wenshiducaiji();</span><br><span class="line">  Serial.println(&quot;Voltage in 4&quot;); </span><br><span class="line">  Serial.println(digitalRead(4));</span><br><span class="line">  if(!lowPowerRate || digitalRead(4) == HIGH) &#123;</span><br><span class="line">    getFingerprintID();</span><br><span class="line">  &#125;</span><br><span class="line">  delay(checkDelay);            //don&#x27;t ned to run this at full speed.</span><br><span class="line">  guanggan();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void openAndReset()&#123;</span><br><span class="line">  for(pos = 0; pos &lt; 90; pos += 1)&#123;    // 舵机从0°转到180°，每次增加1°          </span><br><span class="line">    myservo.write(pos);       // 给舵机写入角度   </span><br><span class="line">    delay(servoDelay);                    // 延时15ms让舵机转到指定位置</span><br><span class="line">  &#125;</span><br><span class="line">  delay(servoStop);</span><br><span class="line">  for(pos = 90; pos&gt;=1; pos-=1) &#123;    // 舵机从180°转回到0°，每次减小1°                               </span><br><span class="line">    myservo.write(pos);        // 写角度到舵机     </span><br><span class="line">    delay(servoDelay);                 // 延时15ms让舵机转到指定位置</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">uint8_t getFingerprintID() &#123;</span><br><span class="line">  uint8_t p = finger.getImage();</span><br><span class="line">  switch (p) &#123;</span><br><span class="line">    case FINGERPRINT_OK:</span><br><span class="line">      Serial.println(&quot;Image taken&quot;);</span><br><span class="line">      break;</span><br><span class="line">    case FINGERPRINT_NOFINGER:</span><br><span class="line">      Serial.println(&quot;No finger detected&quot;);</span><br><span class="line">      return p;</span><br><span class="line">    case FINGERPRINT_PACKETRECIEVEERR:</span><br><span class="line">      Serial.println(&quot;Communication error&quot;);</span><br><span class="line">      return p;</span><br><span class="line">    case FINGERPRINT_IMAGEFAIL:</span><br><span class="line">      Serial.println(&quot;Imaging error&quot;);</span><br><span class="line">      return p;</span><br><span class="line">    default:</span><br><span class="line">      Serial.println(&quot;Unknown error&quot;);</span><br><span class="line">      return p;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  // OK success!</span><br><span class="line"> </span><br><span class="line">  p = finger.image2Tz();</span><br><span class="line">  switch (p) &#123;</span><br><span class="line">    case FINGERPRINT_OK:</span><br><span class="line">      Serial.println(&quot;Image converted&quot;);</span><br><span class="line">      break;</span><br><span class="line">    case FINGERPRINT_IMAGEMESS:</span><br><span class="line">      Serial.println(&quot;Image too messy&quot;);</span><br><span class="line">      return p;</span><br><span class="line">    case FINGERPRINT_PACKETRECIEVEERR:</span><br><span class="line">      Serial.println(&quot;Communication error&quot;);</span><br><span class="line">      return p;</span><br><span class="line">    case FINGERPRINT_FEATUREFAIL:</span><br><span class="line">      Serial.println(&quot;Could not find fingerprint features&quot;);</span><br><span class="line">      return p;</span><br><span class="line">    case FINGERPRINT_INVALIDIMAGE:</span><br><span class="line">      Serial.println(&quot;Could not find fingerprint features&quot;);</span><br><span class="line">      return p;</span><br><span class="line">    default:</span><br><span class="line">      Serial.println(&quot;Unknown error&quot;);</span><br><span class="line">      return p;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  // OK converted!</span><br><span class="line">  p = finger.fingerSearch();</span><br><span class="line">  if (p == FINGERPRINT_OK) &#123;</span><br><span class="line">    Serial.println(&quot;Found a print match!&quot;);</span><br><span class="line">    digitalWrite(beep,LOW);//关闭蜂鸣器</span><br><span class="line">  &#125; else if (p == FINGERPRINT_PACKETRECIEVEERR) &#123;</span><br><span class="line">    Serial.println(&quot;Communication error&quot;);</span><br><span class="line">    return p;</span><br><span class="line">  &#125; else if (p == FINGERPRINT_NOTFOUND) &#123;</span><br><span class="line">    Serial.println(&quot;Did not find a match&quot;);</span><br><span class="line">    digitalWrite(beep,HIGH);//打开蜂鸣器</span><br><span class="line">    delay(1000); </span><br><span class="line">    digitalWrite(beep,LOW);//打开蜂鸣器</span><br><span class="line">    return p;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    Serial.println(&quot;Unknown error&quot;);</span><br><span class="line">    return p;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  // found a match!</span><br><span class="line">  Serial.print(&quot;Found ID #&quot;); Serial.print(finger.fingerID);</span><br><span class="line">  Serial.print(&quot; with confidence of &quot;); Serial.println(finger.confidence);</span><br><span class="line"> </span><br><span class="line">  openAndReset();</span><br><span class="line"> </span><br><span class="line">  return finger.fingerID;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// returns -1 if failed, otherwise returns ID #</span><br><span class="line">int getFingerprintIDez() &#123;</span><br><span class="line">  uint8_t p = finger.getImage();</span><br><span class="line">  if (p != FINGERPRINT_OK)  return -1;</span><br><span class="line"> </span><br><span class="line">  p = finger.image2Tz();</span><br><span class="line">  if (p != FINGERPRINT_OK)  return -1;</span><br><span class="line"> </span><br><span class="line">  p = finger.fingerFastSearch();</span><br><span class="line">  if (p != FINGERPRINT_OK)  return -1;</span><br><span class="line"> </span><br><span class="line">  // found a match!</span><br><span class="line">  Serial.print(&quot;Found ID #&quot;); Serial.print(finger.fingerID);</span><br><span class="line">  Serial.print(&quot; with confidence of &quot;); Serial.println(finger.confidence);</span><br><span class="line">  return finger.fingerID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//光感函数</span><br><span class="line">void guanggan()&#123;</span><br><span class="line">  int val=analogRead(lightR);  //读取模拟接口A0的值，也就是14号口，把值赋给val</span><br><span class="line">  Serial.println(&quot;光感模拟量值为：&quot;);  //显示字符串&quot;模拟量值为：&quot;</span><br><span class="line">  Serial.println(val);    //通过串口打印对应的val值，并且通过串口进行显示出来</span><br><span class="line">  delay(1000);//延时1秒</span><br><span class="line">  if(val&gt;300)//判断是否大于设定值</span><br><span class="line">   &#123;</span><br><span class="line">      digitalWrite(LED,HIGH);//点亮led</span><br><span class="line">      //digitalWrite(beep,LOW);//关闭蜂鸣器</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">     digitalWrite(LED,LOW);//关闭led</span><br><span class="line">     //digitalWrite(beep,HIGH);//打开蜂鸣器 </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//可燃检测</span><br><span class="line">void huoyanbaojing()</span><br><span class="line">&#123;</span><br><span class="line">  int vall = analogRead(A1);//读取模拟14口的值 </span><br><span class="line">  Serial.println(&quot;可燃模拟量值为：&quot;);  //显示字符串&quot;模拟量值为：&quot;</span><br><span class="line">  Serial.println(vall);    //读取模拟接口A0的值，并且通过串口进行显示出来</span><br><span class="line">  if(vall&gt;1000)//可以通过调节这个参数来改变火焰检测的阀值</span><br><span class="line">  &#123; </span><br><span class="line">    digitalWrite(beep,LOW);//关闭蜂鸣器</span><br><span class="line">  &#125; </span><br><span class="line">  else//否则 </span><br><span class="line">  &#123; </span><br><span class="line">    digitalWrite(beep,HIGH);//打开蜂鸣器 </span><br><span class="line">    openAndReset();</span><br><span class="line">  &#125; </span><br><span class="line">  delay(1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void wenshiducaiji()&#123;</span><br><span class="line">  DHT.read(DHT11_PIN);</span><br><span class="line">  float RH = DHT.humidity;   //读取湿度数据                       </span><br><span class="line">  float T = DHT.temperature;       //读取温度数据</span><br><span class="line">  Serial.print(&quot;Humidity:&quot;);  //向串口打印 Humidity:</span><br><span class="line">  Serial.print(RH);           //向串口打印湿度数据</span><br><span class="line">  Serial.print(&quot;%&quot;);</span><br><span class="line">  Serial.print(&quot;  Temperature:&quot;);</span><br><span class="line">  Serial.print(T);            //向串口打印温度数据</span><br><span class="line">  Serial.println(&quot;C&quot;); </span><br><span class="line">  if(T&lt;33)//可以通过调节这个参数来改变火焰检测的阀值</span><br><span class="line">  &#123; </span><br><span class="line">    Serial.print(&quot;温度正常&quot;);</span><br><span class="line">    digitalWrite(beep,LOW);//关闭蜂鸣器</span><br><span class="line">  &#125; </span><br><span class="line">  else//否则 </span><br><span class="line">  &#123; </span><br><span class="line">    Serial.print(&quot;温度异常&quot;);</span><br><span class="line">    digitalWrite(beep,HIGH);//打开蜂鸣器</span><br><span class="line">    openAndReset();//开门</span><br><span class="line">  &#125; </span><br><span class="line">  delay(500);                  //延时1000毫秒</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
  </entry>
  <entry>
    <title>银河系vs仙女座星系</title>
    <url>/2023/05/22/hello_world/</url>
    <content><![CDATA[<div class="note-large notel-blue"><div class="notel-title"><p>知识科普</p>
</div><div class="notel-content"><p>银河系与仙女系相撞？<br>在天文望远镜被发明以来，近代天文学得到了突破性的发展，人们能够真切观察到神秘且遥远的宇宙，能深入观测到每一个天体的变化与无穷。 随着天文设备的不断革新，天文学家们在发现了更多的宇宙真实的同时，也察觉到了一些即将发生在未来的灾难——本星系群的仙女座星系将在未来与银河系发生大碰撞。</p>
 </div></div>
<div class="note-large notel-blue"><div class="notel-title"><p>仙女座星系</p>
</div><div class="notel-content"><p>仙女座星系早在18世纪时期就已经被天文学家们察觉到了，伊曼努埃尔·康德甚至在当时就认为这或许是一个巨大的恒星系统，当然，恒星系统不仅仅是指类似于太阳系这样的行星围绕恒星旋转的现象，也指星团或者星系，即一些恒星受到引力约束而互相环绕的系统。 然而由于当时技术并不算发达，这位天文学家的说法一直都没有得到确切的证据，直到上个世纪20年代，另外一位天文学家发现了在仙女座星系的外区检验并且确认了其他属于该星系的恒星，才使得这一说法被证实。 在2012年以前，同样是因为技术上的不足，天文学家们只能凭借着“多普勒效应”，即观测星系恒星光谱线的变化，来分析出仙女座星系在人类观察者视线方向的速度，可我们很难测量出仙女座星系与视线方向垂直的运动速度。</p>
 </div></div>
<div class="note-large notel-blue"><div class="notel-title"><p>多普勒效应</p>
</div><div class="notel-content"><p>根据“多普勒效应”，天文学家们已经得知了仙女座星系在当时正朝着地球以每秒钟120公里的径向速度靠近，可因为缺乏其他的相关数据，天文学家们还无法得知它是否会与银河系发生碰撞。 到了2012年，天文学家们利用哈勃空间望远镜，以其优于地面天文台的强大功能分析了仙女座星系在2010年到2012年两年时间的运动状态，发现它相比银河系而言，切向速度或侧向速度相对来说比切向的接近速度要小。<br>这两个星系的横向速度都比天文学家们之前预测得要小很多，因此他们认为，银河系与仙女座星系或许将在39亿年左右的时间点发生碰撞。</p>
 </div></div>

<div class="note-large notel-blue"><div class="notel-title"><p>仙女座星系与银河系</p>
</div><div class="notel-content"><p>然而在2019年2月26日，美国国家地理却表示，仙女座星系正以每秒300千米的速度奔向银河系，两者发生碰撞的时间并不在39亿年左右，而是会向后推迟6亿年的时间，换句话说，这场灾难大概会发生在45亿年后。</p>
 </div></div>

<div class="note-large notel-blue"><div class="notel-title"><p>地球会受到影响吗？</p>
</div><div class="notel-content"><p>假设我们不考虑其他的复杂影响，只单单猜想当银河系与仙女座星系发生碰撞，地球会变得什么样子呢？能否幸免于难呢？</p>
 </div></div>

<div class="note-large notel-blue"><div class="notel-title"><p>计算机模拟撞击过程</p>
</div><div class="notel-content"><p>可能很多人会认为，两个巨大的星系互相撞击，必然会导致无数的恒星相碰撞，进而造成巨量的恒星因为撞击而死亡，同时恒星之间的相撞也会爆发出强烈的辐射和能量等，届时地球周围的环境将会更加恶劣和危险。 若是不幸运的话，太阳系可能也会被“不速之客”影响，地球也将会不复存在。 但是事实却并非如此，因为不管是银河系还是仙女座星系，这两个星系的实际恒星密度都不高，恒星之间的距离非常遥远。</p>
 </div></div>

<div class="note-large notel-blue"><div class="notel-title"><p>哈勃望远镜拍摄的银河系内球状星团M15</p>
</div><div class="notel-content"><p>虽然宇宙中各大天体的体积对于人类而言都格外庞大，但是我们需要知道的是，恒星与恒星之间距离单位是以光年为起步的，太阳距离最近的恒星都隔着4.22光年，更别说其他恒星了。 也因此，我国的天文学家苟利军表示，银河系与仙女座星系的相撞对地球的影响非常小。 更有天文学家们针对两者的撞击进行了计算，发现虽然银河系与仙女座星系未来必然会发生撞击，以及融合成一个更大的星系，但两个星系的恒星相撞概率几乎为零，极其渺茫。 这意味着绝大多数的恒星其实都是互相从空隙中穿过，太阳系极大可能并不会受到太多的影响，甚至那时候如果还有人类存在，我们将会从天空中看到史无前例的绚丽“灯光秀”。 尽管从上面来看，地球基本上能够在两大星系的悍然撞击合并下幸免，但是影响地球演化之路的并非仅仅只有星系相撞这一种。 我们需要知道的是，地球本身是非常脆弱的，它之所以能在几十亿年里一直处在太阳的宜居带之中，并且源源不断的在各种各样的灭绝与灾难中重回新生，推动数次大灭绝下残存的物种再次壮大的原因其实是多种因素共同维护而成的。 地球如今的繁荣昌盛，离不开太阳系外的日光层对宇宙辐射的防护，离不开木星强大的引力下对误闯的陨石、小行星等外来物的防线，也离不开地球外几十亿年来默默抵挡了大量危险陨石的月球等等。</p>
 </div></div>

<div class="note-large notel-blue"><div class="notel-title"><p>月球表面</p>
</div><div class="notel-content"><p>如果有一颗巨大的陨石在巧合之下突破了木星的引力牵制，也跨过了月球的第二重防线，直直轰击在地球上，那么引起了第五次大灭绝的惨状将再次发生在地球，甚至若是威力再巨大一些，地球也将会就此沉寂，成为如同火星一样的荒星。 就算我们不考虑陨石坠落等意外现象，太阳作为一颗寿命为100亿年的黄矮星，如今已经走过了它一半的生命之旅，大概有45.7亿年的岁数了。 这也意味着，太阳将会在50亿年左右的时间耗尽内核处的氢元素，核聚变开始燃烧更高质量的元素，太阳也会向外膨胀，直到外层蔓延至地球甚至是火星所在的位置。</p>
 </div></div>

<div class="note-large notel-blue"><div class="notel-title"><p>太阳未来</p>
</div><div class="notel-content"><p>虽然在这里看来，太阳死亡的时间远比银河系与仙女座星系碰撞的时间要晚，但是随着太阳的不断燃烧，其光度大概每10亿年就会增加10%左右，同时温度也在持续缓慢地上升。 如果按照这样的增长速度，地球根本等不到什么太阳变成红巨星，直接将会在10亿年后被过高的温度烤炙地表，导致地表温度过高，液态水也无法再存在，可想而知，以液态水为生存必备条件之一的地球生命也将会走向灭绝。 当然，在10亿年以后生命无法存活的时候，如果人类还存在于地球上，那么我们必然已经想出了应对一切宇宙变化的解决办法。 毕竟人类的科技发展速度是众所周知的迅速，尽管在如今身处时代的洪流中的我们可能无法察觉到科技的变化速度，但是纵观人类历史，我们的科技飞速发展也才过去了短短几百年，却已经日新月异，这是在过去几十年的人们无法想到的盛景。</p>
 </div></div>

<div class="note-large notel-blue"><div class="notel-title"><p>人类未来</p>
</div><div class="notel-content"><p>到了未来，人类可能已经发展出了能在地下生存、利用各种元素制造水源，并且模拟水循环系统，能自行“创造”出一方小世界。 而在太阳即将迎来死亡，地球彻底终结之前，人类必然已经制造出了能星际航行的宇宙飞船，前往另外一颗更加适宜的类地行星，携带着地球本来的物种样本，在遥远的世界里发展出了第二颗“地球”。<br>我们将无惧宇宙，将明白宇宙的一切发展规律，我们会长久地生存下去，直到宇宙熵增到终结。</p>
 </div></div>
]]></content>
      <tags>
        <tag>科普</tag>
      </tags>
  </entry>
</search>
