<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>项目搭建</title>
    <url>/2023/04/25/Arduino01/</url>
    <content><![CDATA[<div class="note-large notel-blue"><div class="notel-title"><p>1、说在前面</p>
</div><div class="notel-content"><div class="note note-success icon-padding"><i class="note-icon fa-solid fa-check-circle"></i><p>1、需求描述</p>
</div>
<div class="note note-default icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>通过识别指纹开发板控制舵机模拟开门的目的。</p>
</div>
<div class="note note-default icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>温湿度烟雾和指纹模块都可以实现让舵机转动。</p>
</div>
<div class="note note-default icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>同时温湿度和烟雾传感器还能控制蜂鸣器。    </p>
</div>
<div class="note note-default icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>检测火焰使风扇转动实现灭火的功能          </p>
</div>
<div class="note note-default icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>传感器：温湿度传感器、烟雾传感器、指纹模块、光感传感器、舵机、蜂鸣器、风扇灭火模块。</p>
</div>


<div class="note note-success icon-padding"><i class="note-icon fa-solid fa-check-circle"></i><p>2、实现流程</p>
</div>
<div class="note note-default icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>功能一:指纹模块+舵机                     </p>
</div>
<div class="note note-default icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>功能二:温湿度传感器+舵机+蜂鸣器          </p>
</div>
<div class="note note-default icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>功能三:烟雾传感器+舵机+蜂鸣器          </p>
</div>
<div class="note note-default icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>功能四:光感传感器               </p>
</div>
<div class="note note-default icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>功能五:风扇模块                </p>
</div>
准备材料。开始实验。
 </div></div>


<div class="note-large notel-blue"><div class="notel-title"><p>2、准备材料</p>
</div><div class="notel-content"><p>使用的材料是：<br>          <div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>指纹识别模块（带USB转TTL板）</p></p>
</div>
          <div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>舵机（度数可调）</p>
</div>
          <div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>温湿度传感器</p>
</div>
          <div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>光感传感器</p>
</div>
          <div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>烟雾传感器</p>
</div>
          <div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>蜂鸣器</p>
</div>
          <div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>风扇模块</p>
</div>
          <div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>LED灯</p>
</div>     
          <div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>若干根合适长度的杜邦线</p>
</div>    </div></div>


<div class="note-large notel-blue"><div class="notel-title"><p>3、指纹调试</p>
</div><div class="notel-content"><p>使用USB转TTL板连接指纹模块和电脑。  </p>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>1、Vi模块电源正输入端（红）——TTL板3.3V(注意)</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>2、Tx串行数据输出（黄）——TTL板Rx</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>3、Rx串行数据输入（白）——TTL板Tx</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>4、GND信号地（黑）——TTL板GND</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>5、打开“设备管理器”查看并记录TTL板的端口号。</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>6、运行指纹程序，打开该端口的指纹模块。</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>7、录入指纹速度慢可以取消勾选“显示图像”。<br>（建议录入指纹时，波特率选择57600）。</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>8、录入指纹完成后拔掉TTL板，使用杜邦线连接开发板指纹模块和舵机。</p>
</div> </div></div>

<div class="note-large notel-blue"><div class="notel-title"><p>4、线路连接</p>
</div><div class="notel-content"><p>准备合适长度的杜邦线若干。</p>
<div class="note note-primary icon-padding"><i class="note-icon fa-solid fa-circle-arrow-right"></i><p>1、舵机连接步骤：</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>舵机（红色） 线为电源线 —— 开发板5V接口（供电）</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>舵机（棕黑色）线为地线 —— 开发板GND接口（地线）</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>舵机（橙黄色）线为信号线 —— 开发板9号口（信号）</p>
</div>
<div class="note note-primary icon-padding"><i class="note-icon fa-solid fa-circle-arrow-right"></i><p>2、指纹模块连接步骤：</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>指纹模块（红色绿色）线延长接成1根线 —— 开发板3.3V口（供电）</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>指纹模块（黑色）线 —— 开发板GND接口（地线）</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>指纹模块（黄色）线 —— 开发板数字2号口（串行数据输出）</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>指纹模块（白色）线 —— 开发板数字3号口（串行数据输入）</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>指纹模块（蓝色）线 —— 开发板数字4号口（感应信号输出）</p>
</div>
<div class="note note-primary icon-padding"><i class="note-icon fa-solid fa-circle-arrow-right"></i><p>3、温湿度模块连接步骤：</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>温湿度模块S引脚 —— 开发板模拟口</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>温湿度模块VCC引脚 —— 开发板VCC引脚</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>温湿度模块GND引脚 —— 开发板GND引脚</p>
</div>
<div class="note note-primary icon-padding"><i class="note-icon fa-solid fa-circle-arrow-right"></i><p>4、光感模块连接步骤：</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>光感模块S引脚 —— 开发板模拟口</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>光感模块VCC引脚 —— 开发板VCC引脚</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>光感模块GND引脚 —— 开发板GND引脚</p>
</div>
<div class="note note-primary icon-padding"><i class="note-icon fa-solid fa-circle-arrow-right"></i><p>5、烟雾模块连接步骤：</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>烟雾模块S引脚 —— 开发板模拟口</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>烟雾模块VCC引脚 —— 开发板VCC引脚</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>烟雾模块GND引脚 —— 开发板GND引脚</p>
</div>
<div class="note note-primary icon-padding"><i class="note-icon fa-solid fa-circle-arrow-right"></i><p>6、蜂鸣器模块连接步骤：</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>蜂鸣器模块数字引脚 —— 开发板数字引脚</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>蜂鸣器模块GND引脚 —— 开发板GND引脚</p>
</div>
<div class="note note-primary icon-padding"><i class="note-icon fa-solid fa-circle-arrow-right"></i><p>7、风扇模块连接步骤：</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>风扇模块GND —— 开发板GND</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>风扇模块VCC —— 开发板VCC</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>风扇模块数字引脚A —— 开发板数字引脚7</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>风扇模块数字引脚B —— 开发板数字引脚8</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>风扇模块火焰模拟口 —— 开发板模拟口</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>风扇模块火焰模拟VCC —— 开发板VCC</p>
</div>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>风扇模块火焰模拟GND —— 开发板GND</p>
</div> </div></div>

<div class="note-large notel-blue"><div class="notel-title"><p>5、代码实现</p>
</div><div class="notel-content"><div class="note note-red icon-padding"><i class="note-icon fa-solid fa-bolt"></i><p>1、把开发板连接电脑，选择开发板的端口（工具→端口→选择端口），复制以下代码进Arduino程序。</p>
</div>
<div class="note note-red icon-padding"><i class="note-icon fa-solid fa-bolt"></i><p>2、如果缺少库文件，就在“工具→管理库”里面搜索添加提示缺失的库即可。</p>
</div>
<div class="note note-red icon-padding"><i class="note-icon fa-solid fa-bolt"></i><p>3、左上角√图标编译验证没问题，就可以上传→至开发板内了。</p>
</div>
<div class="note note-red icon-padding"><i class="note-icon fa-solid fa-bolt"></i><p>4、源代码实现 (代码还须根据实际进行修改和调整)</p>
</div> </div></div>


<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;DFRobot_DHT11.h&gt;</span><br><span class="line">DFRobot_DHT11 DHT;</span><br><span class="line">#define DHT11_PIN A2                  // 对应的是A0引脚</span><br><span class="line">#include &lt;Adafruit_Fingerprint.h&gt;  //声明调用Adafruit_Fingerprint.h库  指纹</span><br><span class="line">#include &lt;Servo.h&gt;    // 声明调用Servo.h库  舵机</span><br><span class="line">Servo myservo;        // 创建一个舵机对象</span><br><span class="line">int pos = 0;          // 变量pos用来存储舵机位置</span><br><span class="line">const int servoDelay = 15;</span><br><span class="line">const int servoStop  = 2000;</span><br><span class="line">const int lowPowerRate = 1;</span><br><span class="line">const int checkDelay = 1000;</span><br><span class="line">const int debug = 0;</span><br><span class="line">int beep = 6;//定义数字口6控制蜂鸣器</span><br><span class="line">int red = 5;//定义数字口5</span><br><span class="line">/*光感*/</span><br><span class="line">#define lightR A0</span><br><span class="line">#define LED 13</span><br><span class="line">/*光感*/</span><br><span class="line"></span><br><span class="line">SoftwareSerial mySerial(2, 3);//黄色串行数据输出&amp;&amp;白色串行数据输入接口（可修改范围A0~A5，2~13）</span><br><span class="line">Adafruit_Fingerprint finger = Adafruit_Fingerprint(&amp;mySerial);</span><br><span class="line">void setup()</span><br><span class="line">&#123;</span><br><span class="line">  pinMode(7, OUTPUT);</span><br><span class="line">  pinMode(8, OUTPUT);</span><br><span class="line">  pinMode(LED,OUTPUT);    //设置连接小灯的引脚为输出模式</span><br><span class="line">  pinMode(lightR,INPUT);</span><br><span class="line">  pinMode(beep,OUTPUT);//设置数字6引脚为输出模式 </span><br><span class="line">  pinMode(red,OUTPUT);//设置数字6引脚为输出模式 </span><br><span class="line">  myservo.attach(9); //舵机信号端口（可修改范围A0~A5，2~13）</span><br><span class="line">  myservo.write(0);</span><br><span class="line">  Serial.begin(9600);</span><br><span class="line">  Serial.println(&quot;Demo Start&quot;);</span><br><span class="line">  while (!Serial);  // For Yun/Leo/Micro/Zero/...</span><br><span class="line">  delay(100);</span><br><span class="line">  Serial.println(&quot;\n\nAdafruit finger detect test&quot;);</span><br><span class="line">  finger.begin(57600);//设置传感器串行端口的数据速率</span><br><span class="line">  delay(5);</span><br><span class="line">  if (finger.verifyPassword()) &#123;</span><br><span class="line">    Serial.println(&quot;Found fingerprint sensor!&quot;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    Serial.println(&quot;Did not find fingerprint sensor :(&quot;);</span><br><span class="line">    while (1) &#123; delay(1); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.println(F(&quot;Reading sensor parameters&quot;));</span><br><span class="line">  finger.getParameters();</span><br><span class="line">  Serial.print(F(&quot;Status: 0x&quot;)); Serial.println(finger.status_reg, HEX);</span><br><span class="line">  Serial.print(F(&quot;Sys ID: 0x&quot;)); Serial.println(finger.system_id, HEX);</span><br><span class="line">  Serial.print(F(&quot;Capacity: &quot;)); Serial.println(finger.capacity);</span><br><span class="line">  Serial.print(F(&quot;Security level: &quot;)); Serial.println(finger.security_level);</span><br><span class="line">  Serial.print(F(&quot;Device address: &quot;)); Serial.println(finger.device_addr, HEX);</span><br><span class="line">  Serial.print(F(&quot;Packet len: &quot;)); Serial.println(finger.packet_len);</span><br><span class="line">  Serial.print(F(&quot;Baud rate: &quot;)); Serial.println(finger.baud_rate);</span><br><span class="line">  finger.getTemplateCount();</span><br><span class="line">  if (finger.templateCount == 0) &#123;</span><br><span class="line">    Serial.print(&quot;Sensor doesn&#x27;t contain any fingerprint data. Please run the &#x27;enroll&#x27; example.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    Serial.println(&quot;Waiting for valid finger...&quot;);</span><br><span class="line">    Serial.print(&quot;Sensor contains &quot;); Serial.print(finger.templateCount); Serial.println(&quot; templates&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void loop()                     // run over and over again</span><br><span class="line">&#123;</span><br><span class="line">  huoyanbaojing();</span><br><span class="line">  wenshiducaiji();</span><br><span class="line">  fengshan();</span><br><span class="line">  Serial.println(&quot;Voltage in 4&quot;); </span><br><span class="line">  Serial.println(digitalRead(4));</span><br><span class="line">  if(!lowPowerRate || digitalRead(4) == HIGH) &#123;</span><br><span class="line">    getFingerprintID();</span><br><span class="line">  &#125;</span><br><span class="line">  delay(checkDelay);            //don&#x27;t ned to run this at full speed.</span><br><span class="line">  guanggan();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void openAndReset()&#123;</span><br><span class="line">  for(pos = 0; pos &lt; 90; pos += 1)&#123;    // 舵机从0°转到180°，每次增加1°          </span><br><span class="line">    myservo.write(pos);       // 给舵机写入角度   </span><br><span class="line">    delay(servoDelay);                    // 延时15ms让舵机转到指定位置</span><br><span class="line">  &#125;</span><br><span class="line">  delay(servoStop);</span><br><span class="line">  for(pos = 90; pos&gt;=1; pos-=1) &#123;    // 舵机从180°转回到0°，每次减小1°                               </span><br><span class="line">    myservo.write(pos);        // 写角度到舵机     </span><br><span class="line">    delay(servoDelay);                 // 延时15ms让舵机转到指定位置</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">uint8_t getFingerprintID() &#123;</span><br><span class="line">  uint8_t p = finger.getImage();</span><br><span class="line">  switch (p) &#123;</span><br><span class="line">    case FINGERPRINT_OK:</span><br><span class="line">      Serial.println(&quot;Image taken&quot;);</span><br><span class="line">      break;</span><br><span class="line">    case FINGERPRINT_NOFINGER:</span><br><span class="line">      Serial.println(&quot;No finger detected&quot;);</span><br><span class="line">      return p;</span><br><span class="line">    case FINGERPRINT_PACKETRECIEVEERR:</span><br><span class="line">      Serial.println(&quot;Communication error&quot;);</span><br><span class="line">      return p;</span><br><span class="line">    case FINGERPRINT_IMAGEFAIL:</span><br><span class="line">      Serial.println(&quot;Imaging error&quot;);</span><br><span class="line">      return p;</span><br><span class="line">    default:</span><br><span class="line">      Serial.println(&quot;Unknown error&quot;);</span><br><span class="line">      return p;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  p = finger.image2Tz();</span><br><span class="line">  switch (p) &#123;</span><br><span class="line">    case FINGERPRINT_OK:</span><br><span class="line">      Serial.println(&quot;Image converted&quot;);</span><br><span class="line">      break;</span><br><span class="line">    case FINGERPRINT_IMAGEMESS:</span><br><span class="line">      Serial.println(&quot;Image too messy&quot;);</span><br><span class="line">      return p;</span><br><span class="line">    case FINGERPRINT_PACKETRECIEVEERR:</span><br><span class="line">      Serial.println(&quot;Communication error&quot;);</span><br><span class="line">      return p;</span><br><span class="line">    case FINGERPRINT_FEATUREFAIL:</span><br><span class="line">      Serial.println(&quot;Could not find fingerprint features&quot;);</span><br><span class="line">      return p;</span><br><span class="line">    case FINGERPRINT_INVALIDIMAGE:</span><br><span class="line">      Serial.println(&quot;Could not find fingerprint features&quot;);</span><br><span class="line">      return p;</span><br><span class="line">    default:</span><br><span class="line">      Serial.println(&quot;Unknown error&quot;);</span><br><span class="line">      return p;</span><br><span class="line">  &#125;</span><br><span class="line">  p = finger.fingerSearch();</span><br><span class="line">  if (p == FINGERPRINT_OK) &#123;</span><br><span class="line">    Serial.println(&quot;Found a print match!&quot;);</span><br><span class="line">    digitalWrite(beep,LOW);//关闭蜂鸣器</span><br><span class="line">  &#125; else if (p == FINGERPRINT_PACKETRECIEVEERR) &#123;</span><br><span class="line">    Serial.println(&quot;Communication error&quot;);</span><br><span class="line">    return p;</span><br><span class="line">  &#125; else if (p == FINGERPRINT_NOTFOUND) &#123;</span><br><span class="line">    digitalWrite(red,HIGH);//提示红灯</span><br><span class="line">    Serial.println(&quot;Did not find a match&quot;);</span><br><span class="line">    digitalWrite(beep,HIGH);//打开蜂鸣器</span><br><span class="line">    delay(1000); </span><br><span class="line">    digitalWrite(beep,LOW);//打开蜂鸣器</span><br><span class="line">    return p;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    Serial.println(&quot;Unknown error&quot;);</span><br><span class="line">    return p;</span><br><span class="line">  &#125;</span><br><span class="line">  Serial.print(&quot;Found ID #&quot;); </span><br><span class="line">  Serial.print(finger.fingerID);</span><br><span class="line">  Serial.print(&quot; with confidence of &quot;); </span><br><span class="line">  Serial.println(finger.confidence);</span><br><span class="line">  openAndReset();</span><br><span class="line">  return finger.fingerID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int getFingerprintIDez() &#123;</span><br><span class="line">  uint8_t p = finger.getImage();</span><br><span class="line">  if (p != FINGERPRINT_OK)  return -1;</span><br><span class="line"> </span><br><span class="line">  p = finger.image2Tz();</span><br><span class="line">  if (p != FINGERPRINT_OK)  return -1;</span><br><span class="line"> </span><br><span class="line">  p = finger.fingerFastSearch();</span><br><span class="line">  if (p != FINGERPRINT_OK)  return -1;</span><br><span class="line"> </span><br><span class="line">  // found a match!</span><br><span class="line">  Serial.print(&quot;Found ID #&quot;); </span><br><span class="line">  Serial.print(finger.fingerID);</span><br><span class="line">  Serial.print(&quot; with confidence of &quot;); </span><br><span class="line">  Serial.println(finger.confidence);</span><br><span class="line">  return finger.fingerID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//光感函数</span><br><span class="line">void guanggan()&#123;</span><br><span class="line">  int val=analogRead(lightR);  //读取模拟接口A0的值，也就是14号口，把值赋给val</span><br><span class="line">  Serial.println(&quot;光感模拟量值为：&quot;);  //显示字符串&quot;模拟量值为：&quot;</span><br><span class="line">  Serial.println(val);    //通过串口打印对应的val值，并且通过串口进行显示出来</span><br><span class="line">  delay(1000);//延时1秒</span><br><span class="line">  if(val&gt;100)//判断是否大于设定值</span><br><span class="line">   &#123;</span><br><span class="line">      digitalWrite(LED,HIGH);//点亮led</span><br><span class="line">      //digitalWrite(beep,LOW);//关闭蜂鸣器</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">     digitalWrite(LED,LOW);//关闭led</span><br><span class="line">     //digitalWrite(beep,HIGH);//打开蜂鸣器 </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//可燃检测</span><br><span class="line">void huoyanbaojing()</span><br><span class="line">&#123;</span><br><span class="line">  int vall = analogRead(A1);//读取模拟14口的值 </span><br><span class="line">  Serial.println(&quot;可燃模拟量值为：&quot;);  //显示字符串&quot;模拟量值为：&quot;</span><br><span class="line">  Serial.println(vall);    //读取模拟接口A0的值，并且通过串口进行显示出来</span><br><span class="line">  if(vall&gt;1000)//可以通过调节这个参数来改变火焰检测的阀值</span><br><span class="line">  &#123; </span><br><span class="line">    Serial.print(&quot;环境正常&quot;);</span><br><span class="line">    digitalWrite(red,LOW);//关闭提示灯</span><br><span class="line">    digitalWrite(beep,LOW);//关闭蜂鸣器</span><br><span class="line">  &#125; </span><br><span class="line">  else//否则 </span><br><span class="line">  &#123; </span><br><span class="line">    Serial.print(&quot;环境异常&quot;);</span><br><span class="line">    digitalWrite(red,HIGH);//打开提示灯</span><br><span class="line">    digitalWrite(beep,HIGH);//打开蜂鸣器 </span><br><span class="line">    openAndReset();</span><br><span class="line">    delay(1000);</span><br><span class="line">    digitalWrite(red,LOW);//关闭提示灯</span><br><span class="line">  &#125; </span><br><span class="line">  delay(1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void wenshiducaiji()&#123;</span><br><span class="line">  delay(1000);</span><br><span class="line">  DHT.read(DHT11_PIN);</span><br><span class="line">  float RH = DHT.humidity;   //读取湿度数据                       </span><br><span class="line">  float T = DHT.temperature;       //读取温度数据</span><br><span class="line">  Serial.print(&quot;Humidity:&quot;);  //向串口打印 Humidity:</span><br><span class="line">  Serial.print(RH);           //向串口打印湿度数据</span><br><span class="line">  Serial.print(&quot;%&quot;);</span><br><span class="line">  Serial.print(&quot;  Temperature:&quot;);</span><br><span class="line">  Serial.print(T);            //向串口打印温度数据</span><br><span class="line">  Serial.println(&quot;C&quot;); </span><br><span class="line">  if(T&lt;33)//可以通过调节这个参数来改变火焰检测的阀值</span><br><span class="line">  &#123; </span><br><span class="line">    Serial.print(&quot;温度正常&quot;);</span><br><span class="line">    digitalWrite(red,LOW);//关闭提示灯</span><br><span class="line">    digitalWrite(beep,LOW);//关闭蜂鸣器</span><br><span class="line">  &#125; </span><br><span class="line">  else//否则 </span><br><span class="line">  &#123; </span><br><span class="line">    Serial.print(&quot;温度异常&quot;);</span><br><span class="line">    digitalWrite(red,HIGH);//打开提示灯</span><br><span class="line">    //digitalWrite(beep,HIGH);//打开蜂鸣器</span><br><span class="line">    openAndReset();//开门</span><br><span class="line">    delay(1000);</span><br><span class="line">    digitalWrite(red,LOW);//关闭提示灯</span><br><span class="line">  &#125; </span><br><span class="line">  delay(500);                  //延时1000毫秒</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void fengshan()&#123;</span><br><span class="line">  int valll = analogRead(A3);</span><br><span class="line">  Serial.println(&quot; &quot;);</span><br><span class="line">  Serial.println(&quot;模拟量值为: &quot;);</span><br><span class="line">  Serial.println(valll);</span><br><span class="line">  if (valll &lt; 600) &#123;</span><br><span class="line">    digitalWrite(7,HIGH);</span><br><span class="line">    digitalWrite(8,LOW);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    digitalWrite(7,LOW);</span><br><span class="line">    digitalWrite(8,LOW);</span><br><span class="line">  &#125;</span><br><span class="line">  //delay(500);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="note-large notel-blue"><div class="notel-title"><p>风扇模块代码</p>
</div><div class="notel-content"> </div></div>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">void setup()&#123;</span><br><span class="line">  Serial.begin(9600);</span><br><span class="line">  pinMode(7, OUTPUT);</span><br><span class="line">  pinMode(8, OUTPUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void loop()&#123;</span><br><span class="line">  int valll = analogRead(A3);</span><br><span class="line">  Serial.println(&quot;模拟量值为: &quot;);</span><br><span class="line">  Serial.println(valll);</span><br><span class="line">  if (valll &lt; 600) &#123;</span><br><span class="line">    digitalWrite(7,HIGH);</span><br><span class="line">    digitalWrite(8,LOW);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    digitalWrite(7,LOW);</span><br><span class="line">    digitalWrite(8,LOW);</span><br><span class="line">  &#125;</span><br><span class="line">  delay(500);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="note-large notel-red"><div class="notel-title"><p>补充</p>
</div><div class="notel-content"><div class="note note-warning icon-padding"><i class="note-icon fa-solid fa-exclamation-circle"></i><p>上述代码还需根据实际整合</p>
</div>
<div class="note note-warning icon-padding"><i class="note-icon fa-solid fa-exclamation-circle"></i><p>代码中可能存在错误的地方</p>
</div>
<div class="note note-warning icon-padding"><i class="note-icon fa-solid fa-exclamation-circle"></i><p>如有误请自行进行更正代码</p>
</div> </div></div>]]></content>
      <tags>
        <tag>Arduino  物联网</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习-神经网络模型</title>
    <url>/2023/05/25/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<div class="note note-success icon-padding"><i class="note-icon fa-solid fa-check-circle"></i><p>恭喜你发现宝藏了，先收藏，在慢慢看吧，看完后相信你会有很大收获。</p>
</div>
<div class="note note-success icon-padding"><i class="note-icon fa-solid fa-check-circle"></i><p>本文章中若有读者已知内容，可自行阅读其他对自己有帮助的内容部分。</p>
</div>

<div class="note-large notel-blue"><div class="notel-title"><p>一、写在前面</p>
</div><div class="notel-content"><p>如果让你设计一个可以识别图像的神经网络，你会怎么做？<br>我之前问过自己这个问题，思来想去，我的答案是：我可能不知道如何下手，梦还没开始就结束了。<br>于是，我有了一个大胆的想法。接下来，我会从头开始，聊聊一个图像识别网络是怎么工作的，每一步算法的原理，以及相关的背景知识。<br>你可能会想，看懂这些需要什么知识呢？其实不需要太深奥的数学知识。我会尽可能把每一步写的通俗易懂，这个过程中我也会搜集一些资料，<br>也是一个不断完善自己知识体系的过程。文中聊得网络，就是大家都比较熟悉的，被玩烂的、作为各大AI芯片厂商性能标杆的Resnet50。<br>个人水平有限，文中如有错误，欢迎联系我指正。</p>
 </div></div>




<div class="note-large notel-blue"><div class="notel-title"><p>二、从像素说起</p>
</div><div class="notel-content"><p>要实现图像识别，最离不开的，就是像素。<br>其实我们都知道，图像是由像素组成的。实际上，神经网络计算，算的就是像素之间的关系，以及这些关系背后可能隐藏的图片信息。相机摄像头像素2000万，拍出来的照片肯定比像素1000万的要清晰我们更容易看到图片中的物体是什么。<br>这是为什么？因为像素越多，像素之间的关系（色彩，轮廓）越丰富，我们所能看到的信息就越多，自然而然获取到的信息就多。<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/647604abf024cca173ce417a.png"
                      alt="图片" title="Magic Gardens"
                ><br>一张1080p的图片，我们可以更容易辨别出图像中的物体是山还是水。这是因为更多的像素会给眼睛更丰富的图片细节<br>但是，你有没有发现，当我们去看一张图片时，我们绝对不是盯着某一个像素或某几个像素看，而是看了整个图像的大部分区域，或者说，大部分像素！<br>因为只有看到了大部分的图片，才能知道图中是座山。正所谓，聚沙成山！绝不是少了一粒沙，山就不是山，多了一粒沙，就变成了山。</p>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>像素局部性 </p>
</div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/647604abf024cca173ce419d.png"
                      alt="图片" title="sui bain"
                ><br>上图哆啦A梦，虽然不是很清晰，像素点数也很少，但一眼望去，依然可以分清是哆啦A梦，甚至，用手捂住一半的图像，依然可以。<br>这是因为人眼对于图像信息的识别，是建立在对像素局部性分析的基础上的。<br>所谓局部性，通俗点说，就是眼睛或大脑会将相邻的像素或大片的像素连接起来分析，从而组合成嘴巴，然后是耳朵，最后是哆啦A梦。<br>神经网络识别图片大致就是这样的原理，它模拟的，就是人们看到图片之后的信息处理过程。<br>当我们盯着一个图片看时，我们首先会获取到图片的细节特征。比如哆啦A梦红色的大嘴巴。但是如果仅仅盯着大嘴巴，又反而让人有一种“只缘身在此山中”的感觉，看不到图片的全貌。<br>因此还需要看一下图像的轮廓。于是，我们的眼睛看图片大致有以下两个过程：<br>瞳孔放大，盯着某一处细节（如大嘴巴）看<br>瞳孔缩小，模糊的看一张图片的大致轮廓<br>两个过程获取的信息叠加。<br>Bingo，看清楚了，是哆啦A梦！那么神经网络是否可以模拟这种瞳孔放大、缩小的方式呢？<br>很幸运，可以！<br>那就是卷积算法。</p>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>卷积</p>
</div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/647604abf024cca173ce4222.png"
                      alt="图片" title="shi ta"
                ><br>卷积的计算示意图<br>卷积核的设计，就可以很直观的模拟这种获取图片信息的方法。<br>人们通过调整卷积核的大小，来达到瞳孔张开、缩小的目的。并且大量的实验和论文表明，卷积这一针对图像局部性识别的算法，可以非常有效的模拟人眼识别物体的过程。关于卷积算法以及卷积核的设计原理，后面会专门来讲，因为卷积这一算法，在图像处理领域，太重要了。<br>我们现在继续沿着像素这一话题讲下去。</p>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>色彩分量RGB</p>
</div>
回到像素这一话题，你有没有想过，为什么一张图片会是彩色的。
学过摄影的小明同学可能这时会回答：因为图片是由RGB三种颜色来表示的，每个像素实际是不同的R/G/B分量的叠加，混合起来，就表示成了不同的颜色。
回答正确。

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64760578f024cca173cee4d7.png"
                      alt="图片" title="hei ni"
                ><br>三张分别表示R&#x2F;G&#x2F;B分量的图片，合成一张彩色图片<br>对于上面一张RGB的图，我们人眼可以很直观的看到红色和蓝色，可以察觉到一张图片的色彩和轮廓。<br>那么，如果让计算机来处理图片，他又是如何知道色彩和轮廓的呢？<br>其实对于计算机来说，一张图片只是一堆数据，计算机是无法知道这堆数据代表的是什么。这就需要人为的给这堆数据一种表示方法，让计算机知道，哦，这1&#x2F;3的数据是红色分量，这1&#x2F;3的是蓝色分量，这些数据（像素）组合起来，可能代表的是个“帽子”。<br>怎么做呢？通过设计数据在计算机中的存储方式来解决。<br>数据在计算机的存储中，最常见的存储方式是连续存储的。比如C语言，定义一个数组，那么数组在内存中的位置是连续的。<br>int data[10] &#x3D; {0,1,2,3,4,5,6,7,8,9};<br>内存怎么理解，它就是一排连着的门牌号的公寓宿舍。门牌号为101里面住着的，是data的第一个数据0。门牌号102里面住着的，是data的第二个数据1，…，以此类推。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64760637f024cca173cf8800.png"
                      alt="图片" title="ni lai"
                ><br>哈利波特的女贞路4号，内存也是类似于门牌号规则，数据就像人一样，存储在以地址为标识的一个个的内存地址上（房子）<br>只不过，在计算机存储器中，没有门牌号，有的都是地址。这个时候，计算机根本就不关心数据是啥，计算机用到的时候，就把数据从内存对应的地址中取出来用。</p>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>计算机是如何取像素数据的</p>
</div>
人们为数据存储设计一种格式，告诉计算机，这堆数据大概是什么样的。只有这样，通过这种约定的方式，计算机才能正确的取到R分量或者B分量。
对于一张图片来说，最常见的两个参数是长和宽，一般用H（height） 和W(width) 来表示，那么RGB三个分量，看作是3个通道（channel），一般用 C 来表示。
如此一来，一张长宽分别是224像素*224像素的RGB图像，就可以用 HWC = [224, 224, 3]来表示。两张类似的图片就用 NHWC = [2, 224, 224, 3]表示，其中N代表图片张数。

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64760741f024cca173d07653.png"
                      alt="图片" title="wo lai"
                ><br>一张图片的抽象数据表示<br>友好的数据表示方法，可以减少大量的计算复杂度。<br>虽然这样表示不太利于人们的直观理解，但是计算机处理这种数据是十分方便的。在目前主流的深度学习框架中，对于图片的数据格式，基本都支持了NHWC或NCHW这种数据摆放格式。说到底，都是为了更高效地进行图片数据的处理和运算。</p>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>总结一下</p>
</div>
这一章，从像素说起，说到了像素具有局部连接性的，人眼识别图像也是通过获取像素的局部连接性信息来完成的。
幸运的是，卷积这一算法，可以很好的模拟这一过程。最后，为了使计算机更高效的处理图片数据，引出NHWC的图片数据表示方法，所以，之后我们说图片，不仅仅局限于图片的长和宽，还多了一个维度信息，那就是channel。
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>加餐</p>
</div>
熟悉OpenCV或者计算机视觉，数字图像处理的同学，可能对于下面的RGB分量中的大神很熟悉。没错，在很多的教程中，这位女神不止一次的出场。
Lena

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/647609d3f024cca173d3097e.png"
                      alt="图片" title="kan lai"
                ><br>这位女士名叫Lena。<br>电气电子工程师学会图像处理汇刊（IEEE Transactions on Image Processing）主编曾在1996年1月出版的一期中解释道，Lena的流行，因为她是一张好的测试图片，其中包含了很多细节，平滑区域，阴影和纹理。</p>
 </div></div>




<div class="note-large notel-blue"><div class="notel-title"><p>三、图像的色彩空间</p>
</div><div class="notel-content"><p>上一章从像素开始，聊到了RGB 这一常见的色彩空间模型。<br>之所以还想继续聊聊RGB 以及另一种色彩空间模型-YUV ，不是说想要以后去学摄影，学学如何需要调节色度、曝光和饱和度啥的。<br>而是在图像识别的深度学习任务中，RGB以及YUV这些概念，总是会时不时的出现一下，让枯燥无味且高度抽象的深度学习算法，突然之间，变得具体一些，光鲜一些。</p>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>RGB</p>
</div>
Red，Green，Blue（RGB）是我们最常见的图像表示方法。这个非常好理解，三原色的融合，几乎可以构造出所有需要的颜色。三张RGB分量图片的融合，就可以构成一幅色彩斑斓的图片。
原图与R G B 三个分量图片

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/647724bef024cca173ed1973.jpg"
                      alt="图片" title="kan xin"
                ><br>平时我们说，分辨率为1920*1080的图片，它代表的是在长宽两个方向上，有 1920 * 1080 个像素，但是，在色彩这个方向上，还有 3 个通道（channel），也就是RGB，往往被我们忽略。<br>我们看到的一个像素点的颜色，在计算系统中，并不是简单的由一个数值来表示的，而是由RGB三个分量的三个数值来表示的。<br>一个像素点的 RGB 表示</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64772716f024cca173eff01e.png"
                      alt="图片" title="kan men"
                ><br>因此，想要计算一张1920*1080的图片的大小，或者说计算这张图片在计算机内存中所占用的大小时，不能仅仅用图片的长度乘以宽度这么算，还需要考虑通道数。</p>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>数值表示和图片大小计算</p>
</div>
我们可能用过画图这一软件来调过颜色。
通过简单的设置红色，绿色，蓝色的数值，就可以在调色板中得到一个颜色。有没有注意到，无论红色，还是绿色，还是蓝色，其表示的数值都没有超过255。
为什么？因为像素值，在计算机语言中，是用一个 int8 的数据来表示的。而 int8，指的是 8bit 无符号整数，其能表示的范围就是 0 - 255。
说到这，我们就可以算一算，一张1920 * 1080 的RGB图像，在计算机的表示中，到底占多少的内存？
很简单，长宽方向上每个像素由 3 个通道组成，每个通道由一个 8 bit 的数值表示，一个 8 bit 数值代表一个字节（Byte）。
因此，一张1920 * 1080的 RGB 图像，占计算机存储大小为1920* 1080 * 3 * 1 Bytes = 6075 KB = 5.9 MB5.9 MB 的内存占用！
大么？和目前动辄几个G的手机内存相比，不算大。
小么？和边缘侧图像识别终端内存，比如摄像头里的嵌入式芯片内存相比，又不算小。
更何况在公路违法拍照的摄像头场景下，在车流量很大的时候，需要实时处理的图片，可远远不止一张！
那怎么办？有没有办法可以在进行图像处理时，减少图片的数据量，从而减少图片大小和内存占用呢？
有，YUV就是其中一种办法。
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>YUV</p>
</div>
YUV是将亮度信息和颜色信息进行编码的一种颜色空间表示方法。和RGB类似，YUV 也使用3个字母维度来表示颜色。为了简单点，我们暂时将这3个值称为Y，U和V。（事实上，YUV的称呼很多，比如Y'CbCr，也很细节，这里不多描述，我们只要知道它是另外一种表示颜色的方法就可以。）
Y 代表亮度，U 代表色彩度，V代表饱和度。
原图

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64772891f024cca173f1300e.png"
                      alt="图片" title="kan men"
                ><br>仅有Y分量也就是亮度，黑白图片</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64772891f024cca173f13023.png"
                      alt="图片" title="kan men"
                ><br>仅有U分量，只有色度</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64772891f024cca173f13064.png"
                      alt="图片" title="kan men"
                ><br>仅有V分量，只有饱和度</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/64772891f024cca173f1307a.png"
                      alt="图片" title="kan men"
                ><br>上面的几张图片，除了原图之外，我们可能更加倾向于使用只有Y分量的图片，也就是那张黑白图像。<br>因为即使没有色彩，但是它的轮廓以及明亮程度，也足以让我们分辨出图片中的物体。其视觉效果远远好于其他两个分量的图片。相反，只有色度和饱和度的图片，反而变得模糊不堪。<br>这就是问题所在！人眼对于亮度具有更高的敏感度，而对色度和饱和度反而显得迟钝一些。<br>说到这，有没发现什么？既然人眼对于色度和饱和度的反应不敏感，那就没有必要把所有的色度和饱和度信息都放在图片里了啊。<br>举个例子，色度和饱和度我隔一个像素放一个，剩下的像素没有饱和度，不就可以了么。没错，是可以，而且效果很好。<br>这就是YUV的不同编码。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/647728e7f024cca173f1de66.png"
                      alt="图片" title="kan men"
                ><br>YUV422编码<br>实际上，YUV的编码方式有很多种，比如YUV444, YUV422等。<br>大致意思就是，保留全部的Y分量（人眼最敏感的亮度分量），但是只保留部分的U&#x2F;V分量（人眼不敏感），以此来减少图片的占用，但又不失重要信息。<br>还记得上面的1920<em>1080的RGB图片的内存占用么，为5.9MB。如果用YUV444的编码，结果也同样是5.9MB，因为YUV444也是全采样，所有的亮度、色度、饱和度信息都保留了。而如果采用YUV422的编码，相当于U分量减少一半，V分量减少一半。<br>那么最终的图片占用大小就变成了1920</em> 1080 * (1 + 0.5 + 0.5) Bytes &#x3D; 4050KB &#x3D; 3.9MB<br>只有3.9MB，减少了1&#x2F;3的内存占用！是不是好很多？更多关于YUV的编码知识，有兴趣的同学可以Google。如果不做相关课题，可以不用深究。<br>我们只需要知道，YUV这一色彩编码方法，在保留亮度这一人眼最敏感信息的基础上，通过降低其他人眼不太需要的信息，可以来达到降低图片大小的目的。<br>就足够了！</p>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>YUV编码的用途</p>
</div>
原始图片，channel数代表的是RGB通道，可以理解为原始图片具有的三个特征。
可在深度学习网络中，随着网络深度的增加，图片的channel数会不断的增大。就拿Resnet50这个网络来说，最后面的一层图片，channel数已经增大到了2048。这时channel代表的信息，早已不再是RGB这种基础的特征了。而是通过了大量的神经网络训练，代表了图片的多种分类特征，比如是猫的特征还是狗的特征。
这个后面会详细说。
YUV这种编码方法，可以用在图片的上下采样中。通过降低或增加通道数，实现图片的上下采样，以此来实现图片的增大或减少，但又不损失太多我们希望保留的信息。
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>总结一下</p>
</div>
这章聊了聊RGB、YUV 两种颜色空间，以及YUV可能的用途和它的优势。
为什么聊这么多关于图片的东西，因为在深度学习处理图像的任务中，图片是原材料。正所谓知己知彼，百战不殆。
了解了图片这一深度学习的原材料之后，我们就可以更加高效的来完成图片数据的处理和分析。就可以开始图像识别的算法之旅了！
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>加餐</p>
</div>
公元663年，唐代诗人王勃游历南昌，登滕王阁而做序，大笔一挥，豪气万丈。
当时的王勃，傲立在滕王阁楼顶时，看到的应该是怎样的一副壮美图景，才使得中国文坛留下了一句千古绝唱。
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>潦水尽而寒潭清， 烟光凝而暮山紫。</p>
</div>
当时的王勃，应该怎么也不会想到，1000年后的今天，聪明华夏后人，将"暮山紫"这一颜色进行了编码。从此，暮山紫，不只存在于人们的想象中，而是精确地存在了计算机里。

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pic.imgdb.cn/item/647728e7f024cca173f1deba.png"
                      alt="图片" title="kan men"
                ><br>暮山紫-RGB：163 171 214 |</p>
 </div></div>

<div class="note-large notel-blue"><div class="notel-title"><p>参考文章</p>
</div><div class="notel-content"><p>后续内容 -&gt; 初识卷积<br><a class="link"   href="https://zhuanlan.zhihu.com/p/554100794" >知乎 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
 </div></div>

<div class="note note-warning icon-padding"><i class="note-icon fa-solid fa-exclamation-circle"></i><p>本人时间精力能力有限，也是刚开始学习这方面内容，准备参赛</p>
</div>
<div class="note note-warning icon-padding"><i class="note-icon fa-solid fa-exclamation-circle"></i><p>文中一些表述难免有疏漏，若有错误请联系我进行更正,谢谢</p>
</div>
<div class="note note-warning icon-padding"><i class="note-icon fa-solid fa-exclamation-circle"></i><p>QQ Email邮箱：<a class="link"   href="mailto:&#49;&#x37;&#x39;&#53;&#x38;&#x34;&#55;&#x38;&#54;&#51;&#64;&#113;&#113;&#x2e;&#x63;&#111;&#109;" >&#49;&#x37;&#x39;&#53;&#x38;&#x34;&#55;&#x38;&#54;&#51;&#64;&#113;&#113;&#x2e;&#x63;&#111;&#109; <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</div>]]></content>
      <tags>
        <tag>深度学习  神经网络  Resnet50</tag>
      </tags>
  </entry>
  <entry>
    <title>VR AND AR</title>
    <url>/2023/06/02/VR%20AND%20AR/</url>
    <content><![CDATA[<div class="note-large notel-blue"><div class="notel-title"><p>AR&amp;VR</p>
</div><div class="notel-content"><p>AR和VR都属于虚拟现实（Virtual Reality）技术标签。AR指增强现实（Augmented Reality），通常是在真实世界中叠加虚拟元素，创造一个融合了现实和虚拟世界的体验；而VR指虚拟现实（Virtual Reality），通常是通过戴上头戴式显示器等设备，让用户沉浸在虚拟环境中。两者都提供了一种新的互动方式，正在被广泛应用于教育、娱乐、医疗、工业制造等领域。</p>
 </div></div>

<div class="note-large notel-blue"><div class="notel-title"><p>虚拟现实VR</p>
</div><div class="notel-content"><p>虚拟现实（英语：virtual reality，缩写VR），简称虚拟环境，是利用电脑模拟产生一个三维空间的虚拟世界，提供用户关于视觉等感官的模拟，让用户感觉仿佛身历其境，可以即时、没有限制地观察三维空间内的事物。用户进行位置移动时，电脑可以立即进行复杂的运算，将精确的三维世界影像传回产生临场感。该技术集成了电脑图形、电脑仿真、人工智能、感应、显示及网络并行处理等技术的最新发展成果，是一种由电脑技术辅助生成的高技术模拟系统。</p>
 </div></div>


<div class="note-large notel-blue"><div class="notel-title"><p>增强现实AR</p>
</div><div class="notel-content"><p>增强现实（Augmented Reality，简称AR），增强现实技术也被称为扩增现实，AR增强现实技术是促使真实世界信息和虚拟世界信息内容之间综合在一起的较新的技术内容，其将原本在现实世界的空间范围中比较难以进行体验的实体信息在电脑等科学技术的基础上，实施模拟仿真处理，叠加将虚拟信息内容在真实世界中加以有效应用，并且在这一过程中能够被人类感官所感知，从而实现超越现实的感官体验。真实环境和虚拟物体之间重叠之后，能够在同一个画面以及空间中同时存在。<br>增强现实技术不仅能够有效体现出真实世界的内容，也能够促使虚拟的信息内容显示出来，这些细腻内容相互补充和叠加。在视觉化的增强现实中，用户需要在头盔显示器的基础上，促使真实世界能够和电脑图形之间重合在一起，在重合之后可以充分看到真实的世界围绕着它。增强现实技术中主要有多媒体和三维建模以及场景融合等新的技术和手段，增强现实所提供的信息内容和人类能够感知的信息内容之间存在着明显不同。</p>
 </div></div>


<div class="note-large notel-blue"><div class="notel-title"><p>发展历史</p>
</div><div class="notel-content"><div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>AR</p>
</div>
AR技术的起源，可追溯到Morton Heilig在20世纪五、六十年代所发明的Sensorama Stimulator。他是一名电影制作人兼发明家。他利用他的多年的电影拍摄经验设计出了叫Sensorama Stimulator的机器。 SensoramaStimulator同时使用了图像、声音、香味和震动，让人们感受在纽约的布鲁克林街道上骑着摩托车风驰电掣的场景。这个发明在当时非常超前。以此为契机，AR也展开了它的发展史。 由于AR技术的颠覆性和革命性，AR技术获得了大量关注。早在20世纪90年代，就有3D游戏上市，但由于当时的AR技术价格较高，其自身延迟较长，设备计算能力有限等缺陷，导致这些AR游戏产品以失败收尾，第一次AR热潮就此消退。到了2014年，Facebook以20亿美元收购Oculus后，类似的AR热再次袭来。在2015和2016两年间，AR领域共进行了225笔风险投资，投资额达到了35亿美元，原有的领域扩展到多个新领域，如城市规划、虚拟仿真教学、手术诊疗、文化遗产保护等。如今，AR、VR等沉浸式技术正在快速发展，一定程度上改变了消费者、企业与数字世界的互动方式。用户期望更大程度上从2D转移到沉浸感更强的3D，从3D获得新的体验，包括商业、体验店、机器人、虚拟助理、区域规划、监控等，人们从只使用语言功能升级到包含视觉在内的全方位体验。而在这个发展过程中，AR将超越VR，更能满足用户的需求。 
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>VR</p>
</div>
1950年之前
虚拟现实VR的概念首先来自于斯坦利·G·温鲍姆（Stanley G. Weinbaum）的科幻小说《皮格马利翁的眼镜（Pygmalion's Spectacles）》，被认为探讨虚拟现实的第一部科幻作品，简短的故事中详细地描述了包括嗅觉、触觉和全息护目镜为基础的虚拟现实系统。
1950年至1970年
莫顿·海利希（Morton Heilig ）在50年代创造一个“体验剧场”，可以有效涵盖所有的感觉，吸引观众注意屏幕上的活动。1962年，他创建一个原型被称为Sensorama，五部短片同时进行多种感官（视觉，听觉，嗅觉，触觉）。Sensorama是机械设备，据说今天仍在使用。大约在同一时间，道格拉斯·恩格尔巴特使用电脑屏幕当作输入和输出设备。
1968年，伊凡·苏泽兰与学生Bob Sproull创造第一个虚拟现实及增强现实头戴式显示器系统。这种头戴式显示器相当原始，也相当沉重，不得不被悬挂在天花板上。该设备被称为达摩克利斯之剑（The Sword of Damocles）。
1970年至1990年
早期的虚拟现实中，值得注意的是阿斯电影地图（Aspen Movie Map），它由麻省理工学院于1978年创建，背景是科罗拉多州阿斯彭，用户可以徜徉在三种街头模式：夏季、冬季和三维模式。前两个模式无论春夏秋冬由研究人员实际拍摄城市街道每一个运动。
Atari公司在1982年成立虚拟现实研究实验室，但是两年后关闭。然而汤姆·齐默尔曼，斯科特·费舍尔，贾瑞恩·拉尼尔仍持续对虚拟现实相关技术的研究和开发。
到了80年代，贾瑞恩·拉尼尔（Jaron Lanier）使“虚拟现实”广为人知。拉尼尔于1985年创办VPL Research研究几种虚拟现实设备，如数据手套、眼睛电话、音量控制。
在此期间，虚拟现实并不广为人知，媒体报导在80年代末逐渐增加。虚拟现实来自边缘文化，例如赛博朋克视为社会变革的潜在手段，毒品文化则称赞虚拟现实不仅是一种新的艺术形式，更是一个全新的领域。虚拟现实开始吸引媒体的报导，人们开始意识到虚拟现实潜力。有些媒体甚至将虚拟现实与莱特兄弟发明飞机相比。
1990年，Jonathan Waldern在伦敦亚历山德拉宫举行的电脑图形90展览会展示“虚拟性”（Virtuality）。这个新系统是种街机，使用虚拟耳机。
1990年至2000年
1991年，SEGA发行SEGA VR虚拟现实耳机街机游戏和Mega Drive。它使用液晶显示屏幕，立体声耳机和惯性传感器，让系统可以追踪并反应用户头部运动。
同年，游戏Virtuality推出，并成为第一大多人虚拟现实网络娱乐系统。它在许多国家发行，包括旧金山内河码头中心一个专门虚拟现实商场。每台Virtuality系统成本为73,000美元，包含头盔和外骨骼手套，是第一个三维虚拟现实系统。
麻省理工学院科学家安东尼奥·梅迪纳设计一个虚拟现实系统，从地球“驾驶”火星车，尽管信号严重延误。该系统被称为“电脑模拟遥控操作”，是虚拟现实的延伸。
1991年，罗莱·克鲁兹·内拉（Carolina Cruz-Neira），丹尼尔·J·桑丁和Thomas A. DeFanti在电子可视化实验室创建第一个可视化立方房间，人们可以看到周遭的其他人。
1994年，SEGA发行SEGA VR-1运动模拟器街机，它能够跟踪头部运动并制造立体3D图像。
1994年，苹果发布QuickTime VR格式。它是与VR广泛链接使用的产品。
1995年7月21日，任天堂完成Virtual Boy并在日本发布。
1995年，西雅图一个组织创造一个“洞穴般的270度沉浸式投影室”，称为虚拟环境剧场。1996年，同一系统在Netscape Communications主办展览会中发表，首次展示虚拟现实连接到网络，内容提要与VRML 3D虚拟世界相链接。
1995年，个人电脑供电的虚拟现实耳机VFX1 Headgear出现，它支持游戏包含天旋地转、星球大战：黑暗力量、System Shock和雷神之锤 (游戏)。
1999年，企业家菲利普·罗斯戴尔（Philip Rosedale）组织林登实验室（Linden Lab），最初的重点是硬件，使电脑用户完全沉浸在360度虚拟现实中。
一个2013年版本的Oculus VR公司的Oculus Rift设备, 这家公司于2014年被Facebook以20亿美元收购。
2001年-至今
经济实惠和方便的Google Cardboard。
2001年，SAS3或SAS Cube成为第一个台式机立体空间，由Z-A生产，2001年4月在法国拉瓦尔完成。
2007年，谷歌推出街景视图，显示越来越多的世界各地全景，如道路，建筑物和农村地区。一个立体3D模式在2010年推出。
2010年，帕尔默·拉奇创办欧酷拉，设计虚拟现实头戴式显示器Oculus Rift。
2013年，任天堂申请专利，提出使用虚拟现实技术概念使2D电视拥有更逼真的3D效果。
2015年7月，OnePlus成为第一家利用虚拟现实推出产品的公司。他们用虚拟现实的平台推出OnePlus 2，在谷歌应用程序Play商店，YouTube上发布。
2016年4月27日，Mojang宣布Minecraft可以在三星Gear VR上使用。
2016年7月，宏达电与电玩商Valve推出个人电脑VR眼镜产品HTC Vive．
2016年7月，指挥家VRconductorVR发布全球首个大空间多人交互VR行业应用。
2018年1月，上海一个团队首先突破技术难点，于CES大会上推出了商用化的个人8K分辨率电脑VR眼镜，两眼各4K，有效消除了近距观看显示器时人眼的纱窗效应。 </div></div>


<div class="note-large notel-blue"><div class="notel-title"><p>应用场景</p>
</div><div class="notel-content"><div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>AR</p>
</div>
随着AR技术的成熟，AR越来越多地应用于各个行业，如教育、培训、医疗、设计、广告等。 
1、教育
AR以其丰富的互动性为儿童教育产品的开发注入了新的活力，儿童的特点是活泼好动，运用AR技术开发的教育产品更适合孩子们的生理和心理特性。例如，市场上随处可见的AR书籍，对于低龄儿童来说，文字描述过于抽象，文字结合动态立体影像会让孩子快速掌握新的知识，丰富的交互方式更符合孩子们活泼好动的特性，提高了孩子们的学习积极性。在学龄教育中AR也发挥着越来越多的作用，如一些危险的化学实验，及深奥难懂的数学、物理原理都可以通过AR使学生快速掌握。 
AR技术具备提升现实情境的清晰直观性和感知冲击力，使得情景式的学习方式更具亲和性、动态性和自然性，在一定程度上能弥补孤独症儿童对现实世界信息和刺激接收迟缓的弱势，以及社交沟通上动机明显不足的劣势，能为孤独症儿童教学情景创设的实现提供新的途径。 
2、健康医疗
近年来，AR技术也越来越多地被应用于医学教育、病患分析及临床治疗中，微创手术越来越多地借助AR及VR技术来减轻病人的痛苦，降低手术成本及风险。此外在医疗教学中，AR与VR的技术应用使深奥难懂的医学理论变得形象立体、浅显易懂，大大提高了教学效率和质量。 
3、广告购物
AR技术可帮助消费者在购物时更直观地判断某商品是否适合自己，以作出更满意的选择。用户可以轻松地通过该软件直观地看到不同的家具放置在家中的效果，从而方便用户选择，该软件还具有保存并添加到购物车的功能。 
4、展示导览
AR技术被大量应用于博物馆对展品的介绍说明中，该技术通过在展品上叠加虚拟文字、图片、视频等信息为游客提供展品导览介绍。此外，AR技术还可应用于文物复原展示，即在文物原址或残缺的文物上通过AR技术将复原部分与残存部分完美结合，使参观者了解文物原来的模样，达到身临其境的效果。 
5、应用于信息检索领域
对于用户需要对某一物品的功能和说明清晰了解时，增强现实技术会根据用户需要将该物品的相关信息从不同方向汇聚并实时展现在用户的视野内。在未来，人们可以在通过扫描面部，识别出此人的信用以及部分公开信息，防止上当受骗，这些技术的实现很大程度上减少了受骗几率，方便用户快速高效的工作。 
6、应用于工业设计交互领域
增强现实技术最特殊的地方就是在于其高度交互性，应用于工业设计中，主要表现为虚拟交互，通过手势、点击等识别来实现交互技术，将虚拟的设备、产品去展示给设计者和用户前，也可以通过部分控制实现虚拟仿真，模仿装配情况或日常维护、拆装等工作，在虚拟中学习，减少了制造浪费以及对人才培训的成本，大大改善了设计的体制，缩短了设计时间提高效率。 
影视影业
当前，虚拟现实技术在影视制作中的应用，主要是通过构建出可与影视场景交互的虚幻三维空间场景，结合对观众的头、眼、手等部位动作捕捉，及时调整影像呈现内容，继而形成人景互动的独特体验。由于目前 VR 影业尚不成熟，在实际制作中会遇到许多困难，如导演人选、拍摄无分镜、剧情的呈现方式等。近年来LED显示屏的点间距、亮度、不受限于尺寸与形状的限制等优势，开始被全球厂商陆续采用，建置成XR (Extended Reality) 虚拟摄影棚或LED显示屏虚拟摄影棚，进行无论电视、电影、商业广告等拍摄，使导演、演员、灯光师、摄影师等幕前幕后工作人员能快速融入拍摄场景，提升现场的视觉沉浸感，并大幅降低后制的时间与成本。
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>VR</p>
</div>
网络直播
传统方式的视频直播中，观众往往不能全方位了解直播对象周围环境状况，无法切身感受现场氛围，而 VR 直播将活动现场还原到虚拟空间中，其优势在于：

<p>身临其境，借助 VR 头显，观众可以身临其境的在现场观看比赛，增加观众观看节目的趣味性；<br>自由选择位置和角度，时刻关注自己感兴趣的场景；<br>互动性强，VR 直播的‚现场‛氛围要远远高于普通显示屏观看，在这种现场气氛的烘托下，观众的情绪极易被充分调动，增加观看愉悦感。<br>此外，VR 直播也面临着多种挑战，如全景相机拼接算法尚不成熟、对网络环境要求较高、传输格式标准未统一带来的渲染制作和编解码等诸多环节问题。</p>
<p>线下主题馆<br>VR 线下主题馆将传统电竞与虚拟现实技术相结合，结合大空间光学动作捕捉系统、精确的多相机同步管理运算系统与特殊体感交互设备等，玩家可以化身为游戏中的虚拟角色，在特定游戏场景中自由行动，同时借助本地网络环境或云平台，让多人、多地的在线合作或对抗成为可能，极大增强了游戏可玩性和趣味性。</p>
<p>数字展馆<br>传统展馆多采用展品陈列、图片展示、人员讲解等方式向观众传达信息，难以实现多角度欣赏、近距离观看功能，很难快速吸引观众兴趣。虚拟现实技术与展馆展示相结合，不仅体现了其开放、共享、多媒体呈现的特点，数字化呈现实体展的全部内容，还突破实体展的时空局限性，利用图文、视频、三维模型等深度资料，对重点展品进行延展和补充，加强了可视化的网络互动体验，使得展览内容更丰富和多样。</p>
<p>文物保护<br>将虚拟现实技术应用于文物保护工作，可以创建数字化的文物保护方法，为文物的保存、修复和展示提供了新的技术手段，让历史得以数字化再现，文明得以信息化传承。如2017 年，兵马俑实施了200亿像素360°全景兵马俑坑展示工程和AI秦始皇兵马俑复原工程。其中200亿像素360°全景兵马俑坑展示工程采用了矩阵全景技术，收录了兵马俑的一号坑和三号坑的高精度全景图资料。</p>
<p>科研教学<br>相比传统的训练方式，医学生使用实体（如小白鼠）解剖的成本不低，且通常无法重复利用。虚拟现实技术则可以帮助医学生在虚拟手术台上反复练习，虽然仍无法完全取代真实练习，但已经可以作为预习和强化记忆的手段，具备在医学领域推广应用条件。</p>
<p>课堂教学<br>在教育场景，虚拟现实技术可通过自然的交互方式，将抽象的学习内容可视化、形象化，为学生提供传统教材无法实现的沉浸式学习体验，提升学生获取知识主动性，实现更高的知识保留度。目前，教育已成为虚拟现实应用行业中发展最快也是最先落地的领域，随着政策的鼓励和市场的驱动，预计虚拟现实教育市场还将持续增长。</p>
<p>运维巡检<br>工业生产制造过程中，为维护设备安全稳定运行而展开的运维巡检工作量非常巨大，虚拟现实技术的到来，使生产人员可以通过安全的数据可视化头显对设备运转状态、生产环境以及潜在隐患等关键信息进行监测和排查，有利于全面、准确、实时了解整体生产制造情况，从而提高生产安全系数和生产效率。</p>
<p>安全消防<br>虚拟现实技术的发展填补了安全消防教育在感知交互需求方面的空白，通过构造出特定的安防培训场景，将传统的教学元素如图形和数据嵌入到生动虚拟环境中，通过模拟特定的危险情景，更容易激发体验者的紧张感并提升专注度，强化事故演练效果。</p>
<p>自动驾驶<br>在不能无限扩大自动驾驶测试车队规模的情况下，通过虚拟现实技术模拟真实道路环境进行测试成为业界主流解决方案，如使用 NVIDIA DGX 和 Tensor RT 3 进行仿真，工程师可以加快道路测试，加快自动驾驶汽车研发量产进度。</p>
<p>产品设计<br>以工业互联网或物联网平台为基础，虚拟现实成为实现数字孪生（Digital Twins）的核心技术之一。依托特定工具软件可以在虚拟空间中构建出与物理世界完全对等的数字镜像，成为将产品研发、生产制造、商业推广三个维度的数据全部汇集的基础，实现了数据信息与真实物理环境间的互动，为进行阶段性数据验证、业务流程参考的提供了重要支撑。</p>
<p>商业营销<br>虚拟现实+商业营销是利用虚拟现实技术，使消费者获得逼真的感官体验，充分调动消费者的感性基因，从而影响其消费决策。虚拟现实+商业营销分为线上和线下两种方式。线上营销是电商 2.0 版，VR&#x2F;AR电商通过三维建模技术与VR&#x2F;AR设备以及交互体验，可以带给消费者更好的消费体验，线下营销则是在产品的实体店或是展示活动现场利用VR&#x2F;AR设备给消费者带来有趣的互动体验，增加消费者的兴趣与购买欲。例如房地产行业，通过使用虚拟现实技术，看房者在线上即可浏览房源的全貌，步入房间查看细节，除了沉浸式的体验之外，还可以得到房间长、宽、高、年限、周边配套等全方位数据展示，便于全面掌握房屋信息；对于开发商或中介商来说，通过分析用户行为数据，可实现房源精准推销的同时节省人力资源投入成本，有助于提升业务成交效率和企业运营收益。</p>
 </div></div>


<div class="note-large notel-blue"><div class="notel-title"><p>参考来源</p>
</div><div class="notel-content"><p>维基百科 <a class="link"   href="https://zh.wikipedia.org/" >维基百科 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>百度百科 <a class="link"   href="https://baike.baidu.com/" >百度百科 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
 </div></div>

]]></content>
      <tags>
        <tag>教育  娱乐  科技</tag>
      </tags>
  </entry>
  <entry>
    <title>赛博朋克</title>
    <url>/2023/05/20/%E8%B5%9B%E5%8D%9A%E6%9C%8B%E5%85%8B/</url>
    <content><![CDATA[<div class="note-large notel-blue"><div class="notel-title"><p>赛博朋克</p>
</div><div class="notel-content"><p>一种科幻流派或视觉美术风格<br>赛博朋克，是“控制论”与“朋克”的合成词。字面意思，就是对”高度机械文明”的反思。该背景大多描绘在未来，建立于“低端生活与高等科技结合”的基础上，拥有先进科学技术，再以一定程度崩坏的社会结构做对比。之后，它从文学向电影、游戏等媒介延伸，催生了赛博朋克文化。同时，它还演变为一种视觉美学风格，被运用到日常生活中的众多领域中 。<br>“赛博朋克”脱胎于在1960-1970年代兴起的科幻小说新浪潮运动。发端于上世纪八十年代。1980年，科幻作家布鲁斯·博斯克创造了这个词，1984年，威廉·吉布森的科幻小说《神经漫游者》将赛博朋克这个词发扬光大，并开启了一种科幻文学类别。拥有五花八门的视觉冲击效果，比如街头的霓虹灯、街排标志性广告以及高楼建筑等，通常搭配色彩是以黑、紫、绿、蓝、红为主，但霓虹灯等只是其中标志，并不是所有霓虹灯相关的都称为赛博朋克 。<br>赛博朋克的情节经常围绕黑客、人工智能及大型企业之间的矛盾而展开。科幻小说家劳仑斯·普尔森曾尝试定义赛博朋克文学运动的内涵和社会思潮——经典的赛博朋克角色是边缘且性格疏远的独行者。他们生活在社会群体的边缘，一个弥漫反乌托邦氛围的未来地球：日常生活受到急剧改变的科技影响，普及的计算机化信息笼罩全球，以及侵入性的人体改造 </p>
 </div></div>

<div class="note-large notel-blue"><div class="notel-title"><p>文化来源</p>
</div><div class="notel-content"><p>“Cyberpunk”这个单词由cyber（网络）和punk（朋克）组成。cyber的词源是cybernetics（控制论），控制论是20世纪重要的思想运动，奠定了冷战后定量社会科学与信息技术时代。朋克则是起源于二战后英国工人阶级社区的亚文化，躁动反叛的青少年通过音乐、服饰、街头行动反抗一切统治权威。治理与反叛，两个矛盾的概念纠缠在一起。<br>1948，诺伯特·维纳发表了跨学科领域的巨著《控制论：关于在动物和机器中控制和通讯的科学》，创造了控制论（Cybernetics）这一概念。“控制论”源于希腊语kybernētēs，意为“治理”。维纳认为人类社会、生物体和自动化机器都可以看作这样的控制系统，系统通过各个组成部分的信息交换和反馈，来完成自我调节与控制。作为一种方法论，控制论融合了机器与生物的界限，也挑战了人类认知与行为的主体性  。</p>
 </div></div>


<div class="note-large notel-blue"><div class="notel-title"><p>文化概念</p>
</div><div class="notel-content"><p>赛博朋克最早作为一种科幻题材出现，最早起源于上世纪六七十年代的新科幻小说潮流，发端于上世纪八十年代，经过长期发展成为了一种亚文化，目前已经不再仅限于科幻小说，而是充分渗透到小说，动漫，电影，游戏，艺术和建筑等多个领域中。在赛博朋克世界里，人成为了不值一提的渺小生物，由于高科技的发展，人与机械的分线开始消失，人工智能的发展诞生了有思想的仿生人，而且人工智能、黑客以及控制财富的大型公司之间产生了冲突，边缘人物则通过高科技来逃避集体意识实现个体的自由，带有反乌托邦的意识。和星际旅行、太空争霸等天马行空式的科幻世界比起来，赛博朋克给人的感觉更为真实，因为它加入了社会矛盾和对人性的思考，反乌托邦和悲观主义色彩都是赛博朋克文化的标签 。<br>赛博朋克最核心的突出特点是“高科技，低生活”（High Tech，Low Life）。字面意思是科技水平高了，但生活质量下降了。从世界观来看，赛博朋克是科技与社会碰撞形成的产物，而且是离现实不远的未来世界，这时候的实体国家通常已经消亡，由垄断公司掌控财富，城市化加剧、社会体系崩塌带来衰败与暴力。通常包含两组反差：视觉层面上，极高的技术水平与极低的生活质量形成反差；故事层面上，强权的科技公司与弱势的底层人民形成反差。在赛博朋克的作品中，一边是闪烁着霓虹灯光的摩天大楼，富人们在此享受生活，但在阴暗的角落里，到处是黑帮、流氓、抢劫犯的身影，穷人们只能靠电子产品来麻痹自己 </p>
 </div></div>


<div class="note-large notel-blue"><div class="notel-title"><p>文化背景</p>
</div><div class="notel-content"><p>朋克最初来自于“二战”之后的英国，当时战后英国的失业率上升，经济萧条，社会死气沉沉，一些年轻人通过音乐的形式，用姿态宣泄着心中的怒火。到了20世纪六、七十年代，这种具有反叛精神的朋克文化跨越大西洋，与美国科幻“新浪潮”（New Wave）结合在一起，形成了赛博朋克的雏形。<br>从科幻文学史的角度来看，上世纪40年代到60年代盛行的“黄金年代”科幻文学已经显得乏力。这些作品对科学的乐观想象和对人类未来的乌托邦幻想已经让读者产生了厌倦。科幻新浪潮的适时出现试图让这种垂死的文体焕然一新，引导科幻小说进入了严肃文学的领域。这类科幻文学聚焦的主题与现实息息相关，不再一味歌颂太空探索、外星殖民的美好愿景，而是探索科技的黑暗面，由此逐渐表现为反乌托邦的叙事风格。诞生于这一时期的赛博朋克有着非常强烈的现实关怀，这些科幻作家试图通过作品来对嬉皮士、性解放、迷幻药文化等各种正在发生的社会运动和变革作出回应。他们意识到，追求效率的科技终将带来一个僵化社会，贫富差距不断拉大，整个社会充斥着对人性的压抑。霓虹灯与阴雨，摩天大楼与贫民窟也是赛博朋克的经典意象。例如香港历史上的九龙城寨，就成为了赛博朋克作品中的城市建筑原型  。</p>
 </div></div>


<div class="note-large notel-blue"><div class="notel-title"><p>发展历史</p>
</div><div class="notel-content"><p>奠定基调<br>1948年，“控制论之父”诺伯特·维纳首次发表控制论思想之时，引发了一场持续半个世纪之久的思想革命。维纳提出的控制论的根本洞见在于，拥有生物系统的人类，在本质上与机器所共享的一套相似的反馈机制。换言之，人类与机器的行为在理论上是可以达成统一的，人类的智能行为是这套机制的外在表现，而机器也可以像人类一样自我学习和进化。<br>1983年，科幻作家布鲁斯·博斯克创造了“赛博朋克”（cyberpunk）：控制论（cybernetics）和朋克（punk）的合成词。并把该名设定为自己短篇小说的名字，形容迷失的年轻一代：他们是抗拒父母的权威、与主流社会格格不入、利用电脑技术钻漏洞和制造麻烦的技术宅。<br>1982年，经典科幻片《银翼杀手》开创了这种高科技背景与低生活成本杂糅、阴冷压抑的美学风格，继而影响后世众多作品  。同年大友克洋发表了漫画《阿基拉》。之后在1988年改编成动画电影《阿基拉》，并且使得“赛博朋克”这个科幻类别被更多的人知晓。<br>1984年，威廉·吉布森发表了《神经漫游者》，这部囊括科幻文学“大满贯“的经典之作采纳了赛博朋克这个词，并自此开启了一种科幻文学的新类别。在小说中描绘了能联结虚拟电脑数位空间（Cyberspace）的黑客（hacker），这也是后来科幻电影《黑客帝国》（Matrix）的框架雏形 。</p>
 </div></div>


<div class="note-large notel-blue"><div class="notel-title"><p>文化符号</p>
</div><div class="notel-content"><p>风格<br>时代背景<br>不久的未来，科技的高速发展改变了社会生活，高智能产品层出不穷，义体人和仿生人屡见不鲜。但是，改变并不意味着改善，大多数人的生活水平并未因此提高。<br>社会背景<br>高等科技导致财富和武力流向科技型寡头企业，社会群落不再以国家和地区划分，而是全都笼罩在由信息技术控制的巨大网络之下，导致社会制度崩坏，贫富差距悬殊。<br>环境背景<br>科技的发展带来自然环境和社会环境的双重破坏，酸雨、沙尘暴、遮天蔽日的乌云，废弃的无人区、拥挤的贫民窟、密集的摩天楼、晦暗的地下城，随处可见 。<br>元素<br>摩天楼<br>赛博朋克里密集而高耸的摩天楼，是未来工业水平的体现，它们占据着高层次的空间地位，同时也暗示着拥有者高不可攀的社会地位。在有些近乎宗教宫殿式的宏伟建筑面前，社会底层的个人力量更显得微不足道。<br>义体人（赛博格）<br>肢体、器官、皮肤，甚至“人”都可以由机械制造，用机体强化人体的“赛博格”，是赛博朋克世界的常客，代表着科幻感和虚幻感。机械的冰冷和人性的温暖，往往在这种混搭的设定中发生置换，从而更加容易触及赛博朋克的实质。<br>义体武器<br>赛博朋克在科技表现上的两大支柱，就是信息网络和生化改造。两者也不是完全分开的，很多时候生化改造的目的就是为了更好地连接网络。如果说《攻壳机动队》和《黑客帝国》是更强调网络这一端，早期的《银翼杀手》更强调生化科技，人造人这一端。<br>朋克时尚<br>赛博朋克也是朋克，所以赛博朋克不会缺少现实中成型的，标榜叛逆的朋克时尚。稍微具体一点，就是无政府朋克这一派的代表元素，包括莫西干头，自由之刺，带钉装饰，皮夹克，长筒靴，纹身等等。其中人们经常将头发染成各种颜色，画上各种彩妆。绿色，蓝色，粉红色等，很多时候也有迷幻和暧昧的色彩。<br>超梦和神经接口<br>尽管已经有全身级别的替换改造，但性质相近的信息接收装置，超梦设备还是表现得比较保守的。更像是强化版的VR。对于虚拟现实可能的危害性，《赛博朋克2077》有了更多的具体想象，算是贴近时代的一面。<br>贫民窟<br>作为富有的对比，贫民窟代表着赛博朋克的底层世界，低下、拥挤、肮脏、混乱。香港的九龙寨城是现实中的典型范例。在动荡的20世纪，在中英的政治博弈中沦为“三不管地带”的九龙寨城，奇迹地发展出自成一体的蛮荒生态，这种社会形态启发了很多的赛博朋克作品。<br>东方元素<br>赛博朋克的世界里有很多的东方文化元素，汉语、日文、艺伎、拉面店等，但这并不是歧视，而是包含西方视角中的东方主义异化感，人类高科技失控的深刻惧怕，以及城市巨大化带来的社会冷漠，赛博朋克的城市或多或少会包含一些有出入的东方元素，不太像真正多元并存的城市，更像是一种突兀的杂糅 。<br>雨<br>赛博朋克世界的天气时常不好，雨水是环境恶劣的一种反映（酸雨）。连绵的雨天，有时用于烘托悲凉的氛围，有时用于呈现错乱的视觉——地上积洼的雨水，倒映着城市上空绚丽的灯光，既是对光源的补充，也延展了这种虚伪的繁华  。<br>人造光<br>由于科技对环境的破坏，赛博朋克的世界里总是黑云密布，导致自然光不足，所以常常用人造光源进行补充；同时，人造光源也用于对科技的展示和信息的传递，比如全息投影、广告屏、霓虹灯……无处不在的人造光源塑造了未来世界的繁华表象，但是也造成了二次污染——光污染。<br>故障艺术<br>现实当中对数码科技的经验，让乱码，卡顿，错位，伪色，声音失真这些设备失灵时的表现，成了一种独有的风格。和《黑客帝国》的字符雨效果类似，赛博朋克的世界，总少不了各种雪花点，伪色，乃至闪烁黑屏。</p>
 </div></div>

<div class="note-large notel-blue"><div class="notel-title"><p>文化分析</p>
</div><div class="notel-content"><p>赛博朋克的风格主线，就是反映出科技高度发展的人类文明，与脆弱渺小的人类个体之间的强烈反差，同时外界与内在，钢铁与肉体，过去与未来，现实与虚幻等矛盾在其中交织。看似对立，宿命却连结在一起。赛博朋克作者试图从侦探小说、黑色电影和后现代主义中汲取元素，描绘20世纪最后20年数码化社会不为人知的一面。赛博朋克的反乌托邦世界，被认为是20世纪中叶大部分人所设想的乌托邦未来的对立面。<br>布鲁斯·斯特林这样总结赛博朋克的特质：“待人如待鼠，所有对鼠的措施都可以同等地施加给人。闭上眼拒绝思考并不能使这个惨不忍睹的画面消失。这就是赛博朋克。”<br>赛博朋克文学有着强烈的反乌托邦和悲观主义色彩。他们通常将视角放在未来科技高度发达的大时代下底层小人物上，描写太平盛世表象下社会的腐朽与人性的堕落，对未来做出悲观的预言。但也是在这阴暗的角落将会诞生怀有希望的英雄。在赛博朋克文学中，大多故事发生在网络上、数码空间中。现实和虚拟现实之间的界线很模糊。此流派经常使用人脑和电脑的直接连接。<br>赛博朋克经常以隐喻义出现，反映了人们对于大公司企业、政府腐败及社会疏离现象的担忧。一些赛博朋克作家试图通过他们的作品，警示人类社会依照如今的趋势将来可能的样子。因此，赛博朋克作品写作的目的是号召人们来改变社会。通常以骄傲，目空一切的态度看待在城市中犄角旮旯生存的过街老鼠为展开。</p>
 </div></div>


<div class="note-large notel-blue"><div class="notel-title"><p>影响评价</p>
</div><div class="notel-content"><p>科技是科幻的底座……在赛博朋克的世界，科技的迅猛究竟带来的是”稳稳的幸福”，还是会导致”妥妥的不幸”。赛博朋克的世界观所揭示的诸多神奇与矛盾，让人在科技之余反思伦理，在物质之外发现精神，在机器之外寻找人性，在岁月之外确认文明。换句话说，它的最大价值或许就在于，让我们在通往未来的时候可以尽早知晓，哪些是康庄大道，哪些是末路歧途  。（人民日报 评）<br>一切看似天马行空的文艺作品，都是在反映创作者当下所处的“现代”。如今身处的，就是一个赛博朋克的时代。这个看似繁荣的空前盛世，其实一直潜藏着人性的深渊，向下滑落的大门，一直为所有人免费敞开。而且不同于可以随意通过“城头变幻大王旗”进行王朝循环的农业时代，工业革命开启的现代科技文明，因为消耗了太多的不可再生能源，已经无法在短期内重新从低技术状态“重启”了。人民从出生起就享受着的、看似天经地义的现代生活，其实是一个高度复杂、脆弱的“纸牌屋”。赛博朋克作品中刺眼的灰暗未来，其实是创作者们对当下读者送来的警示箴言。但希望依然存在，正如人类一步一步凭借理性的认知走到今天的历史所证明的，人性的深渊之中，同样存在着“天使”，存在着打破束缚、超越自我、追求至高自由的渴望与梦想。如何克服本性的束缚、放下固有的思维定式、打破如今诅咒一般越来越“现实主义”的赛博朋克幻想，开拓全新的未来可能，才是当下人类最迫切需要进行的“思维革命”  。（中国科学技术馆 评）</p>
 </div></div>

<div class="note-large notel-blue"><div class="notel-title"><p>相关作品</p>
</div><div class="notel-content"><p>菲利普·K·迪克（1928.12.16—1982.3.2）的作品成为了赛博朋克类型作品的前身。<br>“我所关心的主要问题是：何谓真实？我甚至质疑这个宇宙，我想知道是否它是真实的，我想知道是否我们都是真实的！”迪克常将笔下人物放进虚构的世界，一个被他质疑其构建和制度的世界。这些故事看似荒谬的幻想，角色们发现他们每天生活的世界是个假像，产生自外部的实质世界。所有他的著作都建立在“没有一个单独、客观存在的真实”这个基本假设。<br>菲利普·迪克笔下是一个衰败的世界，是文明的深深没落，是科技的重重沦陷。狄克生前没有得到世人认可，但在他死后，他的书不停地再版。他被惊呼为我们时代的伟大作家和前卫作家，也可能是最让人吃惊和震撼的作家。有人用他的名字设立了科幻奖。他的小说频频被翻拍成电影，除了科幻片史上有名的《银翼杀手》，还有《少数派报告》《全面回忆》《记忆裂痕》《强殖入侵》等。<br>威廉·吉布森（William Gibson）的“蔓生三部曲”<br>威廉·吉布森由于他的小说《神经漫游者》（1984年）而通常被人们与赛博朋克联系起来。他注重风格、角色成长以及传统科幻小说的氛围，神经浪游者曾被授予雨果奖及星云奖。根据术语档案（Jargon File），吉布森对计算机和当今黑客文化认识不深，使他对计算机和黑客在将来的角色有着特别的推测，而这种看法对黑客们来说天真得令人愤怒，却又令他们感到非常刺激。<br>其他著名的赛博朋克作家包括布鲁斯·斯特林（Bruce Sterling）、鲁迪·鲁克（Rudy Rucker）、帕特·卡蒂甘（Pat Cadigan）、杰夫·努恩（Jeff Noon）以及尼尔·斯蒂芬森（Neal Stephenson）。值得一提的是斯蒂芬森，他被认为是后赛博朋克（postcyberpunk）的代表，尽管大多数人认为这个区分很没必要。<br>雷蒙德·钱德勒（Raymond Chandler）因他荒凉的笔触、愤世嫉俗的世界观和残断的文字，强烈地影响了此流派的作者。赛博朋克的世界是一个反乌托邦的、黑色电影（film noir）的绝望世界。菲利普·K·迪克对此流派也有很大影响。他的作品主题包括社会荒颓、人工智能、偏执狂以及现实及某种虚拟现实间模糊的界限。<br>弗诺·文奇，作为赛博朋克流派中活跃的作家，弗诺·文奇拥有极高的声誉，在硬科幻小说写作方面很有一手。他的小说逻辑严密，情节紧凑，展示出科技的奇妙之处，尤以细节的缔造和令人惊叹的预见力著称。大量细致又经得起推敲的描述让虚构出的“异世界”及生活其中的种族几可乱真。 和他本身的科学素养大有关系，弗诺·文奇本身就是数学家和计算机专家。1981年的《真名实姓》使他声名大噪，1992年的《深渊上的火》获得雨果奖，2000年又以该书前传《天渊》击败《哈利·波特与阿兹卡班的囚徒》，再获雨果奖。<br>后期的赛博朋克的电影有雷德利·斯科特1982年所执导的电影《银翼杀手》，是几部菲利普·狄克的著作所改编的电影之一；《捍卫机密》（1995年）和《新玫瑰旅馆》（1998年）。两部电影基于威廉·吉布森的短篇故事，然而票房和评价方面皆不理想；《黑客帝国》系列（1999年-2003年）则是少数非常成功的赛博朋克电影。近期加入此类别的电影制作包含了原本1982年电影的续作《银翼杀手2049》（2017年）、《升级》（2017年）、改编自1990年代日本漫画《铳梦》的《阿丽塔：战斗天使》（2019年），以及2018年Netflix的影集《副本：义体置换》。<br>电子游戏、桌面游戏和桌上角色扮演游戏，例如《赛博朋克2077》和《暗影狂奔》系列，其故事情节经常受赛博朋克文学和电影强烈的影响。90年代初开始，一些时尚和音乐的趋势也被称为赛博朋克。赛博朋克也在日本动画和日本漫画中占据重要位置：《阿基拉》《铳梦》《攻壳机动队》《玲音》《电脑线圈》《死亡代理人》《BLAME!》《心理测量者》《苹果核战记》等作品在当中是最为著名的。</p>
 </div></div>

]]></content>
      <tags>
        <tag>科普  文化  赛博朋克</tag>
      </tags>
  </entry>
  <entry>
    <title>银河系vs仙女座星系</title>
    <url>/2022/05/20/%E9%93%B6%E6%B2%B3%E7%B3%BBvs%E4%BB%99%E5%A5%B3%E5%BA%A7%E6%98%9F%E7%B3%BB/</url>
    <content><![CDATA[<div class="note-large notel-blue"><div class="notel-title"><p>知识科普</p>
</div><div class="notel-content"><p>银河系与仙女系相撞？<br>在天文望远镜被发明以来，近代天文学得到了突破性的发展，人们能够真切观察到神秘且遥远的宇宙，能深入观测到每一个天体的变化与无穷。 随着天文设备的不断革新，天文学家们在发现了更多的宇宙真实的同时，也察觉到了一些即将发生在未来的灾难——本星系群的仙女座星系将在未来与银河系发生大碰撞。</p>
 </div></div>
<div class="note-large notel-blue"><div class="notel-title"><p>仙女座星系</p>
</div><div class="notel-content"><p>仙女座星系早在18世纪时期就已经被天文学家们察觉到了，伊曼努埃尔·康德甚至在当时就认为这或许是一个巨大的恒星系统，当然，恒星系统不仅仅是指类似于太阳系这样的行星围绕恒星旋转的现象，也指星团或者星系，即一些恒星受到引力约束而互相环绕的系统。 然而由于当时技术并不算发达，这位天文学家的说法一直都没有得到确切的证据，直到上个世纪20年代，另外一位天文学家发现了在仙女座星系的外区检验并且确认了其他属于该星系的恒星，才使得这一说法被证实。 在2012年以前，同样是因为技术上的不足，天文学家们只能凭借着“多普勒效应”，即观测星系恒星光谱线的变化，来分析出仙女座星系在人类观察者视线方向的速度，可我们很难测量出仙女座星系与视线方向垂直的运动速度。</p>
 </div></div>
<div class="note-large notel-blue"><div class="notel-title"><p>多普勒效应</p>
</div><div class="notel-content"><p>根据“多普勒效应”，天文学家们已经得知了仙女座星系在当时正朝着地球以每秒钟120公里的径向速度靠近，可因为缺乏其他的相关数据，天文学家们还无法得知它是否会与银河系发生碰撞。 到了2012年，天文学家们利用哈勃空间望远镜，以其优于地面天文台的强大功能分析了仙女座星系在2010年到2012年两年时间的运动状态，发现它相比银河系而言，切向速度或侧向速度相对来说比切向的接近速度要小。<br>这两个星系的横向速度都比天文学家们之前预测得要小很多，因此他们认为，银河系与仙女座星系或许将在39亿年左右的时间点发生碰撞。</p>
 </div></div>

<div class="note-large notel-blue"><div class="notel-title"><p>仙女座星系与银河系</p>
</div><div class="notel-content"><p>然而在2019年2月26日，美国国家地理却表示，仙女座星系正以每秒300千米的速度奔向银河系，两者发生碰撞的时间并不在39亿年左右，而是会向后推迟6亿年的时间，换句话说，这场灾难大概会发生在45亿年后。</p>
 </div></div>

<div class="note-large notel-blue"><div class="notel-title"><p>地球会受到影响吗？</p>
</div><div class="notel-content"><p>假设我们不考虑其他的复杂影响，只单单猜想当银河系与仙女座星系发生碰撞，地球会变得什么样子呢？能否幸免于难呢？</p>
 </div></div>

<div class="note-large notel-blue"><div class="notel-title"><p>计算机模拟撞击过程</p>
</div><div class="notel-content"><p>可能很多人会认为，两个巨大的星系互相撞击，必然会导致无数的恒星相碰撞，进而造成巨量的恒星因为撞击而死亡，同时恒星之间的相撞也会爆发出强烈的辐射和能量等，届时地球周围的环境将会更加恶劣和危险。 若是不幸运的话，太阳系可能也会被“不速之客”影响，地球也将会不复存在。 但是事实却并非如此，因为不管是银河系还是仙女座星系，这两个星系的实际恒星密度都不高，恒星之间的距离非常遥远。</p>
 </div></div>

<div class="note-large notel-blue"><div class="notel-title"><p>哈勃望远镜拍摄的银河系内球状星团M15</p>
</div><div class="notel-content"><p>虽然宇宙中各大天体的体积对于人类而言都格外庞大，但是我们需要知道的是，恒星与恒星之间距离单位是以光年为起步的，太阳距离最近的恒星都隔着4.22光年，更别说其他恒星了。 也因此，我国的天文学家苟利军表示，银河系与仙女座星系的相撞对地球的影响非常小。 更有天文学家们针对两者的撞击进行了计算，发现虽然银河系与仙女座星系未来必然会发生撞击，以及融合成一个更大的星系，但两个星系的恒星相撞概率几乎为零，极其渺茫。 这意味着绝大多数的恒星其实都是互相从空隙中穿过，太阳系极大可能并不会受到太多的影响，甚至那时候如果还有人类存在，我们将会从天空中看到史无前例的绚丽“灯光秀”。 尽管从上面来看，地球基本上能够在两大星系的悍然撞击合并下幸免，但是影响地球演化之路的并非仅仅只有星系相撞这一种。 我们需要知道的是，地球本身是非常脆弱的，它之所以能在几十亿年里一直处在太阳的宜居带之中，并且源源不断的在各种各样的灭绝与灾难中重回新生，推动数次大灭绝下残存的物种再次壮大的原因其实是多种因素共同维护而成的。 地球如今的繁荣昌盛，离不开太阳系外的日光层对宇宙辐射的防护，离不开木星强大的引力下对误闯的陨石、小行星等外来物的防线，也离不开地球外几十亿年来默默抵挡了大量危险陨石的月球等等。</p>
 </div></div>

<div class="note-large notel-blue"><div class="notel-title"><p>月球表面</p>
</div><div class="notel-content"><p>如果有一颗巨大的陨石在巧合之下突破了木星的引力牵制，也跨过了月球的第二重防线，直直轰击在地球上，那么引起了第五次大灭绝的惨状将再次发生在地球，甚至若是威力再巨大一些，地球也将会就此沉寂，成为如同火星一样的荒星。 就算我们不考虑陨石坠落等意外现象，太阳作为一颗寿命为100亿年的黄矮星，如今已经走过了它一半的生命之旅，大概有45.7亿年的岁数了。 这也意味着，太阳将会在50亿年左右的时间耗尽内核处的氢元素，核聚变开始燃烧更高质量的元素，太阳也会向外膨胀，直到外层蔓延至地球甚至是火星所在的位置。</p>
 </div></div>

<div class="note-large notel-blue"><div class="notel-title"><p>太阳未来</p>
</div><div class="notel-content"><p>虽然在这里看来，太阳死亡的时间远比银河系与仙女座星系碰撞的时间要晚，但是随着太阳的不断燃烧，其光度大概每10亿年就会增加10%左右，同时温度也在持续缓慢地上升。 如果按照这样的增长速度，地球根本等不到什么太阳变成红巨星，直接将会在10亿年后被过高的温度烤炙地表，导致地表温度过高，液态水也无法再存在，可想而知，以液态水为生存必备条件之一的地球生命也将会走向灭绝。 当然，在10亿年以后生命无法存活的时候，如果人类还存在于地球上，那么我们必然已经想出了应对一切宇宙变化的解决办法。 毕竟人类的科技发展速度是众所周知的迅速，尽管在如今身处时代的洪流中的我们可能无法察觉到科技的变化速度，但是纵观人类历史，我们的科技飞速发展也才过去了短短几百年，却已经日新月异，这是在过去几十年的人们无法想到的盛景。</p>
 </div></div>

<div class="note-large notel-blue"><div class="notel-title"><p>人类未来</p>
</div><div class="notel-content"><p>到了未来，人类可能已经发展出了能在地下生存、利用各种元素制造水源，并且模拟水循环系统，能自行“创造”出一方小世界。 而在太阳即将迎来死亡，地球彻底终结之前，人类必然已经制造出了能星际航行的宇宙飞船，前往另外一颗更加适宜的类地行星，携带着地球本来的物种样本，在遥远的世界里发展出了第二颗“地球”。<br>我们将无惧宇宙，将明白宇宙的一切发展规律，我们会长久地生存下去，直到宇宙熵增到终结。</p>
 </div></div>
]]></content>
      <tags>
        <tag>科普  宇宙</tag>
      </tags>
  </entry>
</search>
